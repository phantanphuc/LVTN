
\documentclass[a4paper,12pt]{article}
\usepackage{vntex}
\usepackage{a4wide, fancyhdr}
\usepackage{amsmath}
\newcommand\numberthis{\addtocounter{equation}{1}\tag{\theequation}}
\usepackage{amsthm}
\usepackage{float}
\usepackage{multicol,longtable,amscd}
\usepackage[framemethod=tikz]{mdframed}% For highlighting paragraph backgrounds
\usepackage{caption,subcaption}
\usepackage{tabularx} % in the preamble
\usepackage{tikz}
\usetikzlibrary{shapes, calc, shapes, arrows}
\usepackage{pgfplots}
\usepackage{bbm}
\usepackage{titletoc,tocloft}
\DeclareMathOperator*{\argminB}{argmin} 
\DeclareMathOperator*{\argmaxB}{argmax} 
\setlength\arrayrulewidth{0.2pt}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{color}

\usepackage{lastpage}
\usepackage[lined,boxed,commentsnumbered]{algorithm2e}
\usepackage{enumerate}
\usepackage{graphicx}							% Standard graphics package
\usepackage{array}
\usepackage{tabularx, caption}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{rotating}
\usepackage{graphics}
\usepackage{subcaption}
\usepackage{makecell}
\usetikzlibrary{arrows,snakes,backgrounds}
\usepackage[unicode]{hyperref}
\hypersetup{urlcolor=blue,linkcolor=black,citecolor=black,colorlinks=true} 

\setlength{\headheight}{40pt}
\pagestyle{fancy}
\fancyhead{}

\graphicspath{ {Images/} }

\fancyhead[L]{
	\begin{tabular}{rl}
		\begin{picture}(25,25)(0,0)
		\put(0,-8){\includegraphics[width=8mm, height=8mm]{Images/hcmut.png}}
		\end{picture}&
		\begin{tabular}{l}
			\textbf{\bf \ttfamily Trường Đại Học Bách Khoa Tp.Hồ Chí Minh}\\
			\textbf{\bf \ttfamily Khoa Khoa Học và Kỹ Thuật Máy Tính}
		\end{tabular}
	\end{tabular}
}

\fancyhead[R]{
	\begin{tabular}{l}
		\tiny \bf \\
		\tiny \bf 
\end{tabular}  }
\fancyfoot{} % clear all footer fields
\fancyfoot[L]{\scriptsize \ttfamily Nhận dạng biểu thức toán học}
\fancyfoot[R]{\scriptsize \ttfamily Trang {\thepage}/\pageref{LastPage}}
\renewcommand{\headrulewidth}{0.3pt}
\renewcommand{\footrulewidth}{0.3pt}

\renewcommand{\thesection}{Chương \arabic{section}}
\renewcommand\thesubsection{\arabic{subsection}}


\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{3}
\makeatletter
\newcounter {subsubsubsection}[subsubsection]
\renewcommand\thesubsubsubsection{\thesubsubsection .\@alph\c@subsubsubsection}
\newcommand\subsubsubsection{\@startsection{subsubsubsection}{4}{\z@}%
	{-3.25ex\@plus -1ex \@minus -.2ex}%
	{1.5ex \@plus .2ex}%
	{\normalfont\normalsize\bfseries}}
\newcommand*\l@subsubsubsection{\@dottedtocline{3}{10.0em}{4.1em}}
\newcommand*{\subsubsubsectionmark}[1]{}
\makeatother

\everymath{\color{blue}}%make in-line maths symbols blue to read/check easily

%\sloppy
\captionsetup[figure]{labelfont={small,bf},textfont={small,it},belowskip=-1pt,aboveskip=-9pt}

\captionsetup[table]{labelfont={small,bf},textfont={small,it},belowskip=-1pt,aboveskip=7pt}

\setlength{\floatsep}{5pt plus 2pt minus 2pt}
\setlength{\textfloatsep}{5pt plus 2pt minus 2pt}
\setlength{\intextsep}{10pt plus 2pt minus 2pt}

\newcommand{\myFrame}[2]{%
	\noindent
	\begin{tikzpicture}
	\node[inner sep=2em,draw=green!50!black,line width=1pt,
	fill=red!15, 
	text width=\dimexpr\textwidth-4em-\pgflinewidth\relax] 
	(T) {#2};
	\node[rounded rectangle, inner sep=1ex, 
	draw=green!50!black,line width=1pt,fill=green!10,
	text width=10cm,align=center,
	font=\bfseries\sffamily,
	anchor=center] 
	(H) at (T.north) {\textcolor{red}{#1}};
	%\draw (H.south west) rectangle (H.north east);
	\end{tikzpicture}%
	\par
}
\usepackage{tocbibind}
\newcommand{\listofalgorithmes}{\tocfile{\listalgorithmcfname}{loa}}

\begin{document}
	\begin{titlepage}
		
		\begin{center}
			ĐẠI HỌC QUỐC GIA THÀNH PHỐ HỒ CHÍ MINH \\
			TRƯỜNG ĐẠI HỌC BÁCH KHOA\\
			KHOA KHOA HỌC - KỸ THUẬT MÁY TÍNH\\
			
		\end{center}
		\vspace{1cm}
		
		\begin{figure}[h!]
			\begin{center}
				\includegraphics[width=3cm]{Images/hcmut.png}
			\end{center}
		\end{figure}
		\vspace{1cm}
		
		\begin{center}
			\begin{tabular}{c}
				\multicolumn{1}{c}{\textbf{{LUẬN VĂN TỐT NGHIỆP ĐẠI HỌC}}}\\
				~~\\
				\hline
				\\
				\multicolumn{1}{c}{\textbf{{\Large
							Nhận dạng biểu thức toán học viết tay
				}}}\\
				
			\end{tabular}
		\end{center}
		
		\vspace{1cm}
		
		\begin{table}[h]
			\begin{tabular}{rrl}
				%\vspace{0.5cm}
				%\hspace{1.5 cm} & Hội đồng & : \bf{Khoa học máy tính}\\
				\vspace{0.5cm}
				\hspace{1.5 cm} & Giảng viên hướng dẫn & : \bf{TS. Lê Thành Sách}\\
				
				\vspace{0.5cm}
				\hspace{1.5 cm} & Nhóm sinh viên thực hiện & : \bf{Phan Tấn Phúc - 51303058}\\
				%	\vspace{0.5cm}
				\hspace{1.5 cm} & \hspace{5 cm} &  \hspace{0.15cm} \bf{Bùi Khánh Ngọc - 51302567}\\
				
			\end{tabular}
		\end{table}
		\vspace{2cm}
		\begin{center}
			{\footnotesize Tp. Hồ Chí Minh, Tháng 12/2017}
		\end{center}
	\end{titlepage}
	\newpage
	\subsection*{Lời cam đoan}
	Luận văn của nhóm có tham khảo các tài liệu từ nhiều nguồn khác nhau và các nguồn tham khảo này đều được trích dẫn rõ ràng trong phần tài liệu tham khảo. Ngoài những phần được trích dẫn, nhóm xin cam đoan toàn bộ nội dung báo cáo là do các thành viên nhóm tự soạn thảo dựa trên những tìm hiểu và kết quả thực tế do nhóm tạo ra. \\
	Thành viên nhóm sẽ hoàn toàn chịu xử lý theo quy định nếu có bất kỳ sai phạm nào xảy ra liên quan đến những gì nhóm đã cam đoan.
	\begin{table}[h]
		\begin{tabular}{lll}
			%\vspace{0.5cm}
			\hspace{8cm} Hồ Chí Minh, ngày 08 tháng 12 năm 2017\\
			\hspace{10cm}Nhóm sinh viên thực hiện\\
			%\vspace{0.5cm}
			\hspace{10.5cm}\textbf{Phan Tấn Phúc}\\
			%\vspace{0.5cm}
			\hspace{10.5cm}\textbf{Bùi Khánh Ngọc}
		\end{tabular}
	\end{table}
	
	\newpage 
	\subsection*{Lời nói đầu}
	
	Luận văn tốt nghiệp là thử thách cuối cùng của chặng đường 4.5 năm trên giảng đường đại học của những sinh viên Bách Khoa. Nó khép lại một giai đoạn mà ở đó chứa đựng đầy những nỗ lực, những phấn đấu, cả niềm vui và thỉnh thoảng là những nỗi buồn, sự luyến tiếc. Nhưng cũng từ đây một cánh cửa mới sẽ mở ra- cánh cửa của lao động, của cống hiến. 
	
	Để đi đến thời điểm này, nhóm muốn gửi lời cảm ơn chân thành đến Ban giám hiệu và các thầy cô Trường Đại học Bách Khoa Thành phố Hồ Chí Minh, cách riêng cho các thầy cô Khoa Khoa học và Kỹ thuật Máy tính đã chỉ dẫn cho các thành viên nhóm trong suốt những năm học vừa qua.
	
	Trong quá trình thực hiện luận văn, nhóm đã nhận được rất nhiều sự hỗ trợ về mặt chuyên môn cũng như những đóng góp trong vấn đề xây dựng tập dữ liệu cho đề tài từ các anh và các bạn trong và ngoài khoa Khoa học và Kỹ thuật Máy tính. Chính sự giúp sức này là động lực và cũng là sức mạnh giúp nhóm vượt qua những khó khăn trong quá trình thực hiện và đến thời điểm này có thể nói đã hoàn thành thành công. Nhóm xin bày tỏ sự cảm kích và biết ơn chân thành đến những con người này, cách riêng cho Thạc sĩ Huỳnh Chí Kiên- người anh đã luôn hỗ trợ và đưa ra những lời khuyên hữu ích bất kỳ khi nào nhóm gặp khó khăn. 
	
	Trên tất cả, lời cảm ơn chân thành nhất và sâu sắc nhất xin được gửi đến thầy hướng dẫn đề tài- Tiến sĩ Lê Thành Sách. Cảm ơn thầy đã luôn theo sát, hỗ trợ cũng như định hướng công việc cho nhóm. Cảm ơn thầy đã luôn tạo ra áp lực để thúc đẩy sinh viên của mình tiến về phía trước và cũng cảm ơn thầy vì những khi áp lực nhất đều được thầy chia sẻ. 
	
	Nhóm cũng không quên gửi lời cảm ơn đến nhóm tác giả khoá 2011\cite{qak} và tác giả Kuangliu\cite{github} vì trong quá trình thực hiện luận văn, nhóm có sử dụng mã nguồn của các tác giả này.
	
	Sau cùng, vì những hạn chế về mặt thời gian cũng như khả năng trong cách trình bày và viết báo cáo nên không thể tránh khỏi những thiếu sót, rất mong nhận được sự thông cảm và những ý kiến đóng góp từ quý thầy cô và các bạn để giúp nhóm hoàn thiện hơn.
	
	Chân thành cảm ơn.
	
	\begin{table}[h]
		\begin{tabular}{lll}
			%\vspace{0.5cm}
			\hspace{8cm} Hồ Chí Minh, ngày 08 tháng 12 năm 2017\\
			\hspace{10cm}Nhóm sinh viên thực hiện\\
			%\vspace{0.5cm}
			\hspace{10.5cm}\textbf{Phan Tấn Phúc}\\
			%\vspace{0.5cm}
			\hspace{10.5cm}\textbf{Bùi Khánh Ngọc}
		\end{tabular}
	\end{table}
	
	\newpage
	\subsection*{Tóm tắt luận văn}
	
	Luận văn  này chỉ ra quá trình thực hiện của nhóm từ tìm hiểu những kiến thức cần thiết đến hiện thực đề tài và đánh giá kết quả đạt được. Bố cục của luận văn gồm 6 chương, không kể các mục lục, phụ lục khác. 
	
	Chương 1 là chương giới thiệu tổng quan đề tài. Ở đó sẽ trình bày thế nào là nhận dạng biểu thức toán học, nhu cầu của nó trong xã hội cũng như đưa ra lý do vì sao nhóm chọn đề tài này và sau cùng là quá trình thực hiện của nhóm từ sau giai đoạn thực tập tốt nghiệp.
	
	Chương 2 sẽ đề cập những kiến thức liên quan trực tiếp đến đề tài mà nhóm đã tìm hiểu, cụ thể là kiến trúc mạng SSD.
	
	Chương 3 tóm lược một số công trình liên quan trực tiếp đến đề tài. Trong mục này, nhóm sẽ giới thiệu 4 công trình là cơ sở tham khảo cho quá trình hoàn thiện luận văn. 
	
	Chương 4 trình bày về phương pháp đã được sử dụng để hiện thực đề tài luận văn. Phương pháp này được xây dựng dựa trên những kiến thức đã tìm hiểu được trình bày ở chương 2 và những công trình được giới thiệu ở chương 3.
	
	Chương 5 chỉ ra quá trình hiện thực đề tài bao gồm chuẩn bị tập dữ liệu, xây dựng hệ thống và chương trình thử nghiệm. Cụ thể, nhóm sẽ diễn giải về cách cấu hình, các thông số trong từng giai đoạn của quá trình nhận dạng. Tiếp theo, nhóm sẽ giới thiệu cách thức thu thập dữ liệu cùng một số mô tả cho tập dữ liệu hiện tại mà nhóm đang sử dụng. Cuối cùng là kết quả từ chương trình thử nghiệm và những so sánh, đánh giá giữa các mô hình được tạo ra từ việc thay đổi một số yếu tố liên quan đến quá trình nhận dạng. 
	
	Chương 6 đánh giá tổng kết luận văn. Nhóm sẽ nêu lên những điều còn tồn đọng và những điểm nổi bật, cũng như hướng phát triển tiếp theo của đề tài. Ngoài ra, sẽ là một vài dòng đúc kết lại chặng đường thực hiện luận văn tốt nghiệp của các thành viên nhóm: những điều đã học được, cảm xúc khi hoàn thành đề tài luận văn.
	\newpage
	\setlength{\cftsecnumwidth}{3cm}
	\tableofcontents
	\newpage
	\listoffigures
	\newpage
	\listoftables
	\newpage
	
	\subsection*{Danh mục từ viết tắt}
	
	
	
	\begin{table} [!htb]
		\centering
		\begin{tabular}{| m{4cm} | m{12cm}|}\hline
			\multicolumn{1}{|c|}{\textbf{Thuật ngữ}} & 
			\multicolumn{1}{|c|}{\textbf{Giải thích}}\\\hline
			CNN & Mạng nơron tích chập (Convolutional Neural Network)\\\hline
			NN & Mạng nơron truyền thống \\\hline
			MSE & Mean Square Error\\\hline
			%& t\\\hline
		\end{tabular}
	\end{table}
	
	\newpage
	\section{Giới thiệu}
	\subsection{Giới thiệu đề tài}
	\label{subsec: introduce}
	Khoa học công nghệ phát triển đồng nghĩa với việc xã hội "trở nên tự động hoá" bởi lẽ con người ngày càng có nhu cầu tìm kiếm sự hỗ trợ từ các thiết bị công nghệ và hạn chế dùng sức lực của chính mình. Dựa trên nền tảng công nghệ và nhu cầu của xã hội, hàng loạt những thiết bị, ứng dụng công nghệ ra đời. Chúng phục vụ nhu cầu của con người trong đời sống hằng ngày cũng như trong hầu hết mọi lĩnh vực của xã hội từ giao thông, y tế, thương mại,... đến giáo dục. Trong lĩnh vực y tế, phải kể đến ứng dụng giám sát sức khoẻ người dùng trên những chiếc đồng hồ thông minh của Apple hay SamSung. Với giao thông, những ứng dụng chỉ đường, định vị và giám sát xe đề phòng trộm ngày càng phổ biến và giúp ích thực sự cho con người. Riêng với giáo dục, vấn đề thường gặp đối với các bạn học sinh là giải, trực quan hoá các phương trình, hàm số toán học hay soạn các giáo án chứa nhiều công thức, ký hiệu phức tạp đối với thầy cô. Họ cần một giải pháp nào đó giúp giảm thiểu công sức trong những tình huống như vậy. Giải pháp này cần phải giải quyết những vấn đề cơ bản sau:
	
	\begin{itemize}
		\item Số hoá các công thức in trong sách hay được viết tay.
		\item Giải tham khảo một số dạng phương trình.
		\item Trực quan hoá các hàm số
		\item Biểu diễn công thức, ký hiệu dưới những lệnh mà các trình soạn thảo toán có thể hiểu được, ví dụ Latex.
		\item ...
		
	\end{itemize}
	
	
	
	\subsection{Lý do chọn đề tài}
	Bởi sự cần thiết về một ứng dụng nhận dạng biểu thức toán học đã được trình bày ở mục \ref{subsec: introduce}, trên thị trường cũng đã xuất hiện nhiều sản phẩm như vậy, đáng chú ý là PhotoMath\footnote{Một ứng dụng về nhận dạng và giải các biểu thức toán học nổi bật trên Google Play.}. Tuy nhiên, nhóm nhận thấy thách thức nếu phải hiện thực thành công đề tài này. Một số câu hỏi đã được đặt ra:\\
	\begin{itemize}
		\item Làm sao có thể nhận dạng được các ký hiệu?
		\item Làm cách nào để nhận dạng cả một biểu thức?
		\item Làm sao biết được đây là loại biểu thức gì?
		\item Liệu có chắc chắn bất kỳ những gì mình viết ra đều được hiểu đúng? 
		\item Nhóm có thể tạo ra được một sản phẩm hoàn thiện như PhotoMath không?
		
	\end{itemize}
	
	Để tự mình trả lời những câu hỏi đó, nhóm quyết tâm thực hiện đề tài này. Ngoài ra, việc áp dụng kiến thức đã học để tạo ra một sản phẩm vừa cần thiết cho xã hội vừa tự bản thân mình có thể sử dụng được tạo cho nhóm một động lực đế tiến hành. 
	
	\subsection{Phạm vi đề tài}
	
	\begin{itemize}
		\item Nhận dạng biểu thức toán học viết tay dạng offline\footnote{Nhận dạng từ ảnh chứa biểu thức toán học.}.
		\item Chuyển biểu thức từ dạng hình ảnh sang dạng máy có thể hiểu được (Latex).
		\item Ảnh nhận diện ít nhiễu và không bị xoay quá nhiều.
		\item Nhận diện được các cấu trúc đơn giản (tích phân, tổng, chỉ số trên, chỉ số dưới, phân số, giới hạn, ...)
		
	\end{itemize}
	
	\subsection{Quá trình thực hiện}
	Bước 1: Tìm hiểu những công trình trong nước và nước ngoài liên quan đến vấn đề nhận dạng biểu thức toán học.
	\begin{itemize}
		\item Mục tiêu: 
		\begin{itemize}
			\item Biết được khả năng giải quyết vấn đề của các hệ thống nhận dạng biểu thức toán học đã được xây dựng.
			\item Hiểu được phương pháp mà các nhóm tác giả sử dụng để thực hiện công trình của họ.
		\end{itemize}
		\item Công việc: 
		\begin{itemize}
			\item Tìm kiếm và chọn lọc những bài báo với nội dung nhận dạng biểu thức toán học.
			\item Đọc và nghiên cứu các thông tin được cung cấp bởi các bài báo.
			\item Tải mã nguồn (nếu có), chạy thử nghiệm.
		\end{itemize}
	\end{itemize}
	Bước 2: Chọn ra một phương pháp trong các phương pháp đã đọc để hiện thực.\\
	\begin{itemize}
		\item Mục tiêu: 
		\begin{itemize}
			\item Xây dựng từ đầu một hệ thống nhận dạng biểu thức toán học theo phương pháp đề xuất.
			\item Kiểm chứng độ chính xác được nêu trong bài báo và thực tế nhóm làm được. Trên cơ sở đó, tiến tới việc cải tiến để thu được kết quả tốt hơn.
		\end{itemize}
		\item Công việc:
		\begin{itemize}
			\item Đọc kỹ lại bài báo đã chọn.
			\item Tìm hiểu những kiến thức được giới thiệu trong bài báo ở mức độ có thể vận dụng được.
			\item Triển khai và hiện thực phương pháp.
		\end{itemize}	
	\end{itemize}
	%\vspace{1.5cm}
	Bước 2+\footnote{2+ là phương án thay thế của bước 2. Vì trong quá trình thực hiện bước 2, nhóm không thu được kết quả như mong đợi nên dẫn tới việc chọn một cách tiếp cận khác để giải quyết vấn đề.}: Lựa chọn một phương pháp mới để giải quyết đề tài trên cơ sở mã nguồn mở đã có.
	
	\begin{itemize}
		\item Mục tiêu: 
		\begin{itemize}
			\item Có được phương án thay thế phương án cũ không khả thi.
			\item Có được chương trình thử nghiệm.
		\end{itemize}
		\item Công việc:
		\begin{itemize}
			\item Tìm và tải bộ mã nguồn liên quan đến vấn đề nhận dạng biểu thức toán học\cite{github}.
			\item Thiết lập và chạy thử mã nguồn.
			
		\end{itemize}
	\end{itemize}
	Bước 3: Đề xuất phương pháp.
	\begin{itemize}
		\item Mục tiêu:
		\begin{itemize}
			\item Quyết định phương pháp giải quyết vấn đề của nhóm.
			
		\end{itemize}
		\item Công việc:
		\begin{itemize}
			\item Thay đổi, hoàn thiện mã nguồn trên cơ sở phương pháp nhóm đề xuất.
			
		\end{itemize}
	\end{itemize}
	Bước 4: Xây dựng tập dữ liệu
	\begin{itemize}
		\item Mục tiêu:
		\begin{itemize}
			\item Có được dữ liệu phục vụ quá trình huấn luyện và kiểm thử hệ thống của nhóm.
			
		\end{itemize}
		\item Công việc:
		\begin{itemize}
			\item Liên hệ nhóm sinh viên Khoá 2011\footnote{Nhóm sinh viên này đã từng hiện thực đề tài nhận dạng biểu thức toán học} để nhận được toàn bộ tập dữ liệu của họ bao gồm ảnh của các ký tự toán học.
			\item Chuẩn bị mẫu thu và bổ sung thêm ảnh cho một số loại ký tự mới.
			\item Xây dựng bộ ảnh chứa đựng các biểu thức toán học từ đơn giản đến phức tạp.
		\end{itemize}
	\end{itemize}
	Bước 5: Cải tiến phương pháp
	\begin{itemize}
		\item Mục tiêu:
		\begin{itemize}
			\item Hoàn thiện hệ thống nhận dạng biểu thức toán học.
		\end{itemize}
		\item Công việc:
		\begin{itemize}
			\item Kết hợp kiến thức và kết quả thử nghiệm trên tập dữ liệu để tìm ra phương pháp cải tiến.
			\item Xây dựng các phiên bản thử nghiệm khác nhau dựa trên các yếu tố có thể cải tiến.
			
		\end{itemize}
	\end{itemize}
	Bước 6: Xây dựng chương trình demo và đánh giá kết quả
	\begin{itemize}
		\item Mục tiêu:
		\begin{itemize}
			\item Có kết quả đánh giá và điều chỉnh phương pháp sao cho phù hợp.
			\item Có chương trình demo cho luận văn.
		\end{itemize}
		\item Công việc:
		\begin{itemize}
			\item Xây dựng bản demo.
			\item Xem xét ưu, nhược điểm của các cải tiến dựa trên đánh giá các độ đo.
			\item Cấu hình và lựa chọn phương án cải tiến khả thi. 
		\end{itemize}
	\end{itemize}
	
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	
	\newpage
	\section{Kiến thức đã tìm hiểu}
	\subsection{Mạng nơ-ron tích chập (CNN)}
	
	\subsection{Mạng Single Shot Multibox Detector\cite{liu2016ssd}}
	
	SSD như là một mạng cải tiến của phương pháp phát hiện bằng cửa sổ trượt\footnote{Thuật ngữ tiếng Anh: Sliding Window}. Thay vì sử dụng một (một số) cửa sổ có kích thước cố định, thì SSD sinh ra một số lượng hữu hạn các \textbf{ô chuẩn} \footnote{Thuật ngữ tiếng Anh: Default box} để rồi từ các ô chuẩn đó để hệ thống có thể xác định vị trí các ký tự cần nhận diện cho quá trình huấn luyện, qua đó mạng cần phải học cách dự đoán cả kích thước của các \textbf{ô bọc}\footnote{Thuật ngữ tiếng Anh: Bounding box} quanh ký tự thay vì chỉ chấp nhận kích thước cho trước. SSD cũng sử dụng các lớp tích chập\footnote{Thuật ngữ tiếng Anh: Convolution layer} (hay cụ thể hơn là các mạng nơ-ron tích chập\footnote{Convolutional neural network}) để trích đặc trưng, tạo tiền đề cho việc phát hiện và phân loại ký tự. \\
	
	Nhóm xin phép được tách quá trình huấn luyện thành ba giai đoạn: mã hóa, phát hiện - phân loại và tính giá trị lỗi. Và song song với huấn luyện, quá trình kiểm tra, kiểm định, chạy thực tiễn cũng được chia thành ba giai đoạn: trích đặc trưng - phân loại và giải mã.
	
	\subsubsection{Bộ mã hóa (Encoder)}
	Bộ mã hóa chỉ được sử dụng trong quá trình huấn luyện nhằm mã hóa, chuyển đổi "đáp án" \footnote{Thuật ngữ tiếng Anh: Ground truth} thô (được lưu trong tệp tin định dạng txt hoặc xml) sang "đáp án" mà mạng SSD\cite{liu2016ssd} có thể hiểu được.
	
	\subsubsection*{Sinh ô chuẩn}
	
	Để mã hóa "đáp án", bộ mã hóa trước hết có nhiệm vụ sinh ra nhiều ô chuẩn có nhiều kích thước khác nhau, để làm được điều này, mạng cần phải được cung cấp một số thông số:\\
	\begin{itemize}
		\item Danh sách kích thước của các feature map (Phần này sẽ được giải thích rõ hơn ở mục sau): Mỗi feature map trong danh sách tương ứng với một mức kích thước\footnote{Thuật ngữ tiếng Anh: Scale} trong việc phát hiện ảnh. Trong một mức kích thước, tất cả các ô chuẩn đều có kích thước như nhau và cách đều nhau, mỗi pixel trong feature map thể hiện một (một số ô chuẩn), vì vậy, ta có thể tính được danh sách khoảng cách giữa trọng tâm giữa các ô chuẩn bằng cách lấy kích thước ảnh chia cho kích thước của feature map ở mức kích thước tương ứng. Tất cả các dữ liệu liên quan đến kích thước sau đó sẽ được chuyển về tập giá trị $\{x \in R | x \in [0, 1] \} $ 
		\item Danh sách các tỉ lệ diện mạo\footnote{Thuật ngữ tiếng Anh: Aspect ratio} ứng với mỗi mức kích thước. Mạng SSD dựa vào các tỉ lệ diện mạo đó để tạo ra các ô chuẩn có hình dạng khác nhau tại cùng một vị trí (trọng tâm của các ô chuẩn có cùng một vị trí).
		\item Kích thước nhỏ nhất và lớn nhất của các ô chuẩn.
	\end{itemize} 
	
	Từ những thông số trên, các ô chuẩn sẽ được sinh ra theo các bước sau: \\
	Trước hết, bộ phận này tiến hành sinh ra kích thước của ổ chuẩn ứng với mỗi mức kích thước tương ứng bằng công thức: 
	\begin{align}
	s_k = s_{min} + \frac{s_{max} - s_{min}}{m - 1}(k - 1) 
	\end{align}
	Trong đó $s_{min}$ và $s_{max}$ là kích thước nhỏ nhất và lớn nhất của ô chuẩn, m là số lượng feature map. Việc chọn các thông số này khá quan trọng vì nó sẽ ảnh hưởng đến các ký tự có thể nhận diện được sau này, các kích thước cần được chọn sao cho không quá lớn cũng như không quá nhỏ đối với những đối tượng được kỳ vọng nhận diện được.\\
	
	Ứng với mỗi mức kích thước:
	
	\begin{itemize}
		
		\item Mỗi ô chuẩn đều được liên kết với một điểm ảnh trên feature map, ta cũng đã tính được danh sách khoảng cách trọng tâm theo đề cập ở trên. Từ đó ta dễ dàng tính được tọa độ của các trọng tâm của các ô chuẩn trong ảnh theo công thức:
		\begin{align}
		(x, y) =\left( \left(i + \frac{1}{2} \right) \times step, \left(j + \frac{1}{2} \right) \times step \right)
		\end{align}
		Trong đó: $x$, $y$ là tọa độ của các trọng tâm; $i$, $j$ là các số nguyên dương nằm trong khoảng từ 0 đến kích thước feature map đang xét và $step$ là khoảng cách giữa hai trọng tâm liền kề trong mức kích thước đang xét.
		
		\item Sau khi có được tọa độ của các trọng tâm, bộ phận mã hóa tiến hành sinh các ô chuẩn ứng với mỗi vị trí trọng tâm: 
		
		\begin{itemize}
			\item Tạo một ô chuẩn có kích thước $s_k$ là kích thước ứng với mức kích thươc $k$ hiện tại.
			\item Tạo một ô chuẩn có kích thước bằng $\sqrt{s_k \times s_{k + 1}}$.
			\item Với mỗi phần tử trong danh sách tỉ lệ diện mạo tương ứng, ta tạo một ô chuẩn có kích thước chiều rộng: 
			\begin{align}
			w = s_k \times \sqrt{aspect\_ratio}
			\end{align} 
			và chiều cao:
			\begin{align}
			h = s_k \div \sqrt{aspect\_ratio}
			\end{align}
			với $aspect\_ratio$ là tỉ lệ diện mạo đang xét.
		\end{itemize}
		
	\end{itemize}
	
	Như vậy, với mỗi vị trí được chọn để đặt trong tâm các ô chuẩn, bộ phận mã hóa sẽ sinh ra $2 + n$ ô chuẩn với $n$ là số tỉ lệ diện mạo ứng với mức kích thước hiện tại. Kết quả của quá trình sinh ô chuẩn là một tập hợp nhiều vector. Mỗi vector ứng với một ô chuẩn mang thông tin tọa độ trọng tâm, chiều dài, chiều rộng của ô chuẩn.
	
	\subsubsection*{Kết hợp\footnote{Thuật ngữ tiếng Anh: Matching}}
	
	Sau khi hoàn tất sinh ô chuẩn, bộ phận encoder có nhiệm vụ kết hợp dữ liệu thô là các ô bọc \footnote{Thuật ngữ tiếng Anh: Bounding box} từ "đáp án"\footnote{Thuật ngữ tiếng Anh: Ground truth} qua các ô chuẩn vừa được tạo. Kết quả là ta sẽ thu được một tập nhiều vector, mỗi vector đại diện cho mỗi ô chuẩn chứa thông tin gồm tọa độ trọng tâm, kích thước của ô chuẩn và nhãn của ô chuẩn đó là gì (có thể là phần nền - không có gì cả, hoặc một ký tự nào đó cần được nhận diện). \\
	
	Việc kết hợp được thực hiện bằng cách so sánh từng ô chuẩn với từng ô bọc trong "đáp án" bằng cách tính chỉ số Jaccard\cite{Jaccard}, nếu chỉ số này thỏa điều kiện thì ô chuẩn đó được gán nội dung là kí tự chứa trong ô bọc phù hợp nhất, nếu không thì ô chuẩn được gán nội dung là "nền".\\
	
	Chỉ số Jaccard\cite{Jaccard} giữa hai ô bọc được tính bằng công thức:
	\begin{align}
	J(A, B) = \frac{A \cap B }{ A \cup B }
	\end{align}
	Trong đó, A, B lần lượt là phần ảnh mà ô bọc A và ô bọc B chiếm. Công thức này mang ý nghĩa hai ô bọc có kích thước càng tương đồng và phần trùng nhau càng nhiều thì có chỉ số Jaccard\cite{Jaccard} càng gần giá trị 1.\\
	
	\begin{center}
		\centering
		\includegraphics[width=0.5\linewidth]{Intersection_over_Union_-_visual_equation.png}
		\vspace{0.5cm}
		\captionof{figure}{Mô phỏng chỉ số Jaccard\cite{Jaccard}}
	\end{center}
	
	Các ô bọc này có bản chất như một "hệ quy chiếu" cho các ô bọc, sau quá trình kết hợp, các ô bọc "đáp án" được tính độ lệch so với các ô chuẩn tương ứng và khi huấn luyện, mạng SSD\cite{liu2016ssd} có nhiệm vụ dự đoán các ô bọc theo các độ lệch đó. Giá trị hàm lỗi được tính dựa trên độ lêch của ô bọc "đáp án" và độ lệch của ô bọc dự đoán được. Cách tính độ lệch sẽ được đề cập rõ hơn ở phần tính giá trị lỗi.
	
	
	\subsubsection{Bộ phát hiện - phân loại}
	Đây là bộ phận có nhiệm vụ trích đặc trưng từ ảnh thô đầu vào, tạo ra các feature map để đưa vào quá trình phân loại ký tự.
	
	\subsubsection*{Trích đặc trưng (Hay mạng cơ sở \footnote{Thuật ngữ tiếng Anh: Base Network})}
	
	Mạng cơ sở của SSD\cite{liu2016ssd} là một mạng nơron tích chập bất kỳ, có thể là VGG\cite{Simonyan14c} hoặc lenet\cite{yanlecun},... Hầu hết những mạng này có mục đích phân loại\footnote{Thuật ngữ tiếng Anh: Classification}, vì vậy ở phía cuối mạng thường có các lớp liên kết đầy đủ nhằm giảm kích thước feature map và tạo ra dữ liệu đầu ra có kích thước phù hợp (bằng với số nhãn cần dự đoán). Khi kết hợp với mạng SSD\cite{liu2016ssd}, các lớp liên kết đầy đủ này sẽ được thay thế bằng các lớp tích chập và song hành là các bước trích ra feature map để đưa vào lớp Multibox \cite{erhan2014scalable}, chi tiết phần này sẽ được để cập ở mục tiếp theo.
	
	\subsubsection* {Phân loại}
	
	Bộ phận phân loại có nhiệm vụ đưa ra dự đoán về vị trí và nhãn của các ký tự có trong ảnh. Để làm được điều đó, bộ phân loại phải sinh ra các feature map ứng với từng mức kích thước khác nhau, các feature map đó được đưa vào lớp Multibox để sinh ra các vị trí dự đoán và nhãn tương ứng. Các feature map được lấy sau một (một số) lớp tích chập. Danh sách feature map có được ở giai đoạn sinh ô chuẩn chính là được lấy từ đây. \\
	
	\begin{center}
		
		\centering
		\includegraphics[width=0.8\linewidth]{SSD_Struture.png}
		\vspace{0.5cm}
		\captionof{figure}{Cấu tạo của một mạng SSD\cite{liu2016ssd}}
	\end{center}
	
	Sau khi có được các feature map, lớp Multibox sẽ tiến hành đưa ra dự đoán về ô bọc và nhãn gắn với ô bọc đó. Mỗi feature map sử dụng một tập hợp các lớp tích chập sẽ cho ra một số lượng dự đoán nhất định. Với mỗi vị trí trên feature map được kernel trượt qua, thì một dự đoán về ký tự được sinh ra. Kernel có kích thước:
	\begin{align}
	3 \times 3 \times (n \times (classes + 4))
	\end{align}
	Với $n$ là số lượng tỉ lệ diện mạo với fearture map tương ứng và $classes$ là số lượng nhãn cần nhận diện, số $4$ trong công thức đại diện cho 4 thông số về vị trí của ô bọc (tọa độ trọng tâm và kích thước). Do kích thước của các kernel không đồng nhất (vì số lượng tỉ lệ diện mạo ứng với từng feature map có thể khác nhau), nên để tạo ra dữ liệu đầu ra phù hợp với các ô chuẩn đã tạo từ trước thì các vector dự đoán sẽ được sắp xếp lại sao cho dữ liệu đầu ra chỉ có $classes + 4$ kênh và vị trí của các vector phải tương ứng với vị trí các ô chuẩn đã sinh từ trước.
	
	\subsubsection{Tính giá trị lỗi}
	
	Giá trị lỗi được tính bằng tổng có trọng số giữa lỗi về vị trí\footnote{Thuật ngữ tiếng Anh: Localization Loss} và lỗi về độ tin cậy\footnote{Thuật ngữ tiếng Anh: Confidence Loss}
	\begin{align}
	L(x,c,l,g) = \frac{1}{N} (L_{conf}(x,c) + \alpha L_{loc}(x,l,g) )
	\end{align}
	Trong đó:
	\begin{itemize}
		\item x biểu thị các phép kết hợp, cụ thể $x^p_{ij}$ biểu thị phép kết hợp giữa ô chuẩn thứ $i$ với ô bọc thứ $j$ đối với nhãn $p$. Vì vậy $x^p_{ij}$ có tập giá trị $\{0, 1\}$.
		\item $c$ biểu thị nhãn kỳ vọng cho phép kết hợp đang xét.
		\item $l$ biểu thị ô bọc dự đoán.
		\item $g$ biểu thị ô bọc "đáp án".
	\end{itemize}
	
	Hàm lỗi về vị trí có thể được biểu diễn bằng công thức:
	\begin{align}
	L_{loc}(x,l,g) = \sum^N_{i \in Pos} \sum_{m \in \{ cx, cy, w, g \}} x^k_{ij} smooth_{L1} (l^m_i - \hat{g}^m_j)
	\end{align}
	Trong đó:
	\begin{itemize}
		\item N là số lượng phép kết hợp giữa ô chuẩn và ô bọc có ý nghĩa (nhãn của phép kết hợp không phải là "nền". Nếu như $N = 0$ thì ta đặt giá trị lỗi bằng 0.
		\item Pos là tập hợp các phép kết hợp có ý nghĩa.
		\item $smooth_{L1}$ (theo \cite{girshick2015fast}) là một hàm tính lỗi được định nghĩa là:
		\begin{align}
		L(x) = \begin{cases} 0.5x^2 \quad if |x| < 1 \\ |x| - 0.5 \quad otherwise \end{cases}
		\end{align}
		\item \begin{align}\hat{g}_j^{cx} = (g_j^{cx} - d_i^{cx}) / d^w_i\end{align}Với $d$ biểu thị cho ô chuẩn.
		\item \begin{align}\hat{g}_j^{cy} = (g_j^{cy} - d_i^{cy}) / d^h_i\end{align}
		\item \begin{align}\hat{g}^w_j = \log \left( \frac{g_j^w}{d_i^w} \right)\end{align}
		\item \begin{align}\hat{g}^h_j = \log \left( \frac{g_j^h}{d_i^h} \right)\end{align}
	\end{itemize}
	
	Bốn công thức $\hat{g}$ trên chính là độ lệch giữa ô đang xét và ô chuẩn, mà nhóm đã đề cập ở mục trước.
	
	Vậy ta có thể thấy khi tính giá trại lỗi về vị trí, ta tính dựa trên sai lệch so với ô chuẩn mà ô bọc "đáp án" ban đầu kết hợp được thay vì tính lỗi trực tiếp.\\
	
	Hàm lỗi về độ tin cậy có thể được tính theo công thức:
	\begin{align}
	L_{conf}(x, c) = - \sum^N_{i \in Pos} x^p_{ij} \log (\hat{c}^p_i) - \sum_{i \in Neg} \log (\hat{c}^0_i)
	\end{align}
	
	Với \begin{align}\hat{c}_i^p = \frac{\exp{c_i^p}}{\sum_p \exp{c)i^p}}\end{align}
	
	\subsubsection{Bộ giải mã (Decoder)}
	
	Bản chất của bộ giải mã khá đơn giản, nó có chức năng chuyển dữ liệu các ô bọc mà mạng dự đoán (tức là những ô bọc được tính kích thước và tọa độ theo ô chuẩn mà ô bọc đó được kết hợp vào) sang dữ liệu tọa độ của ảnh (có gốc tọa độ nằm ở góc trên bên phải và tọa độ nằm trong miền $[0, 1]$. Dữ liệu này cần thiết để trực quan hóa các ký tự mà hệ thống dự đoán và để đưa vào bộ phân tích cú pháp để sinh mã Latex.
	
	\subsubsection{Một số vấn đề khác trong mạng SSD\cite{liu2016ssd}}
	\subsubsection*{Tăng cường dữ liệu\footnote{Data Augumentation}}
	
	Ngay trước quá trình kết hợp, ảnh và các ô bọc được đi qua một bước gọi là cắt ngẫu nhiên\footnote{Thuật ngữ tiếng Anh: Random Crop}. Ở bước này, ảnh được cắt đi một số phần ngẫu nhiên (có tác dụng giống như phóng to (zoom) ảnh. Điều này giúp làm đa dạng dữ liệu huấn luyện và làm giảm bớt hiện tượng overfit.
	
	
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	
	\newpage
	\section{Công trình liên quan}
	Là một phần quan trọng của hệ thống \textbf{Nhận dạng ký tự thuộc thị giác}\footnote{Thuật ngữ tiếng Anh: Optical Character Recognition, viết tắt OCR.}, nhận dạng \textbf{biểu thức toán học}\footnote{Thuật ngữ tiếng Anh: Mathematical Expression, viết tắt ME.} đã được nghiên cứu trong hơn nửa thế kỷ qua. Đã có rất nhiều công trình tiêu biểu giải quyết những vấn đề xung quanh đề tài này. Trong chương này, nhóm sẽ trình bày tóm lược về 4 công trình- là những điểm tham khảo cho hệ thống nhận dạng biểu thức toán học mà nhóm sẽ hiện thực sau này.\\
	\subsection{Tổng quan}
	Nhận dạng biểu thức toán học bao gồm 2 vấn đề chính: \textbf{nhận dạng ký tự}\footnote{Thuật ngữ tiếng Anh: Symbol recognition.} và \textbf{phân tích cấu trúc}\footnote{Thuật ngữ tiếng Anh: Structural analysis.}. Hai vấn đề này có thể được xử lý tuần tự hoặc kết hợp. Đối với hướng tiếp cận tuần tự, đầu tiên phân tách\footnote{Thuật ngữ tiếng Anh: Segmentation} ảnh chứa biểu thức toán học thành những mảnh ảnh chỉ chứa các ký tự và nhận dạng chúng. Sau đó phân tích cấu trúc 2 chiều của biểu thức toán học dựa trên kết quả phân tách và nhận dạng ký tự ở bước trước đó. Khác với phương pháp xử lý tuần tự, xử lý kết hợp mong muốn thực hiện 2 quá trình nhận dạng ký tự và phân tích cấu trúc một cách đồng thời. \\
	Quan tâm đến cách giải quyết vấn đề nhận dạng biểu thức toán học theo hướng tuần tự, nhóm có liệt kê một số công trình của các tác giả và chỉ ra phương pháp họ sử dụng cho từng giai đoạn cụ thể. Thống kê này được rút trích từ \cite{survey}.
	\begin{center}
		\begin{tabular}{||c | c | c ||} 
			\hline
			Tác giả & \makecell{  Nhận dạng ký tự } & \makecell{ Phân tích cấu trúc} \\ [0.5ex] 
			\hline\hline
			P.A.Chou&\makecell{Template matching} &\makecell{ Stochastic context-\\free grammar}\\ 
			\hline
			M.Okamoto& \makecell{recursive projection\\ và Template matching}&\makecell{ Không parsing}\\ 
			\hline
			J.Ha&\makecell{X-Y cut và mạng nơ-ron}&\makecell{ Expression tree}\\
			\hline
			R.J.Fateman &\makecell{Template matching dựa trên \\khoảng cách Hausdorff}&\makecell{ Recursive descent parser}\\
			\hline
			H.-J.Lee và J.-S.Wang&\makecell{Kỹ thuật rút trích đặc trưng\\ và giải thuật nearest-neighborhood}&\makecell{Expression Tree}\\
			\hline
		\end{tabular}
		\captionof{table}{Một số công trình tiêu biểu về nhận dạng biệu thức toán học trước năm 2000 và các phương pháp được sử dụng.}
	\end{center}
	Dựa trên quan điểm cá nhân, nhóm có một số đánh giá:
	\begin{itemize}
		\item Với các phương pháp phân tách sử dụng phép chiếu như X-Y cut sẽ trở nên khó khăn đối với các ký tự dính liền nhau hoặc những ký tự đặc biệt như dấu căn.
		\item Với phương pháp phân tích cấu trúc sử dụng cấu trúc cây đòi hỏi phải có kiến thức để xây dựng các luật sinh và có giải thuật parse cây phù hợp để có thể phù hợp với cách đọc biểu thức từ trái sang phải cũng như khắc phục được một số lỗi sai liên quan đến ngữ pháp.
%		\item Nhận diện theo hướng phân vùng\footnote{Thuật ngữ tiếng Anh: Segmentation.}. Ở hướng này, bài toán được chia ra thành nhiều bài toán nhỏ hơn thông qua việc phân chia vùng ảnh biểu thức toán học một cách có quy tắc. Một số ví dụ cho phương pháp này như giải thuật X-Y cut \cite{XY} hay dùng phương pháp projection profiles \cite{projection}. Đối với phương pháp này, bài toán sẽ trở nên vô cùng khó khăn với những ký tự dính liền nhau hoặc với những bài toán có dấu căn.
%		
%		\item Nhận diện dựa trên cấu trúc cây hoặc đồ thị. Ở hướng này, dựa vào vị trí các ký tự cũng như cấu trúc tổng thể của biểu thức, biểu thức toán học được biểu diễn theo cấu trúc cây hoặc đồ thị. Một số ví dụ cho phương pháp này như Tapia and Rojas Đã đề xuất một phương pháp nhận diện dựa trên cây trải dài\footnote{Thuật ngữ tiếng Anh: Spanning tree.} và ký tự chủ đạo\footnote{Thuật ngữ tiếng Anh: Dominate symbol.}, Zanibbi cho ra đời phương pháp nhận diện bằng một chuỗi các bước biến đổi cây\cite{zanibbi}. Phương pháp này khá hoàn thiện nhưng vẫn có một số vướng mắc như việc nhận diện ký tự một cách phi ngữ cảnh vẫn mang đến sự thiếu tự nhiên, hay phương pháp đọc từ trái sang phải vẫn để lại nhiều lỗ hổng trong việc nhận diện biểu thức.
%		
%		\item Nhận diện dựa trên ngữ pháp toán học. Ở hướng này, ngữ pháp được đưa vào quá trình nhận diện, ví dụ như sử dụng ngữ pháp để hậu xử lý, loại bỏ, hiệu chỉnh các ý tự nhận diện sai hoặc sử dụng các mô hình ngữ pháp để dự đoán ký tự tiếp theo trong biểu thức.
	\end{itemize}
	\subsection{Công trình tham khảo}
	Dưới đây là những công trình mà nhóm tham khảo trực tiếp để hoàn thành luận văn của mình.
	\subsubsection{Watch, Attend and Parse: An End-to-end Neural Network Based Approach to Handwritten Mathematical Expression Recognition\cite{zhang2017watch}} 
	Để tránh nhưng vấn đề nảy sinh liên quan đến quá trình phân tách và nhận dạng ký tự và việc phải định nghĩa trước những luật ngữ pháp trong quá trình phân tích câu trúc theo hướng tiếp cận tuần tự, nhóm tác giả của công trình này đã đề xuất một phương pháp theo hướng kết hợp mà ở đó họ đồng thời xử lý cả hai quá trình cơ bản của vấn đề nhận dạng biểu thức toán học. Với phương pháp này, họ xây dựng một mạng tích chập dùng để mã hoá ảnh đầu vào tạo ra các đặc trưng- quá trình này được gọi là encode, tiếp theo đó là quá trình decode- những đặc trưng này qua mạng RNN, kết hợp với cơ chế attention\cite{zhang2017watch} mà nhóm tác giả giới thiệu sẽ tao ra được các chuỗi Latex của ảnh biểu thức đầu vào.
	Cụ thể, kiến trúc mạng của họ gồm 2 phần được đặt tên là Watcher- ứng với quá trình encode và Parser- ứng với quá trình decode.
	\begin{itemize}
		\item \textbf{Watcher} thực chất là một mạng nơ-ron tích chập đầy đủ-FCN- với chỉ gồm các lớp tích chập và pooling. Watcher nhận input là một bộ gồm 9 ảnh bao gồm 1 ảnh nhị phân của biểu thức và ảnh 8 hướng của ảnh này. Đầu ra của Watcher là những vector đặc trưng tương ứng với từng pixel trong ảnh. 
		\item \textbf{Parser} là kiến trúc mạng GRU\cite{cho2014properties}, nhận kết quả trả ra của Watcher như input, kết hợp với cơ chế attention để sinh ra chuỗi Latex. Cụ thể, cơ chế attention giúp Parser xác định đúng vùng ảnh để tính toán cho ra ký tự Latex qua từng vòng lặp.
	\end{itemize}
	Dưới đây là mô hình trực quan của phương pháp này.
	\begin{center}
		
		\centering
		\includegraphics[width=0.6\linewidth]{WAP}
		\vspace{0.5cm}
		\captionof{figure}{Hình minh hoạ các bước thực hiện của phương pháp Watch, Attend and Parser.}
	\end{center}
	
%	Khác với những bài báo đi trước sử dụng phương pháp phân vùng hay dựa trên ngữ pháp, bài báo này sử dụng phương pháp mang tên Watch, Attend, Parse dựa trên bài toán chú thích cho ảnh \footnote{Thuật ngữ tiếng anh: Image Captioning}. Hệ thống này là sự kết hợp giữa CNN, RNN và một hệ thống ANN (Cụ thể là GRU\cite{cho2014properties}\footnote{Viết tắt: Gated recurrent unit}), CNN đặc trưng cho Watcher sẽ trích đặc trưng ảnh, ANN đặc trưng cho Attend mang nhiệm vụ điều hướng cho mạng biết được vị trí nào sẽ tập trung vào và RNN đặc trưng cho Parser mang nhiệm vụ sinh ra chuỗi Latex chính là đầu ra của hệ thống\\
%	
%	Cấu trúc mạng này được chia thành ba phần:
%	\subsubsection{Watcher}
%	Bộ phận này có bản chất là một hệ thống mạng nơ-ron tích chập đầy đủ (FCN)\footnote{Thuật ngữ tiếng anh: Fully Convolution Network} có cấu tạo là các lớp tích chập và các lớp pooling xếp chồng lên nhau. Bộ phận này nhận đầu vào là ảnh cần nhận diện và đầu ra là các vector đặc trưng ứng với mỗi pixel của ảnh.
%	
%	\subsubsection{Attend}
%	Bộ phận này hoạt động giống như một hệ thống tổng hợp thông tin, nó có chức năng lấy dữ liệu ký tự vừa được dự đoán từ Parser (sẽ được giải thích bên dưới), từ các vector đặc trưng đã có được từ Watcher và ghi nhận các vị trí đã được xử lý trong ảnh, từ đó dự đoán vị trí tiếp theo để xử lý.
%	
%	\subsubsection{Parser}
%	Bản chất của bộ phận này là một mạng GRU\cite{cho2014properties} nhận dữ liệu đầu vào từ hai bộ phận còn lại, từ đó sinh ra chuỗi Latex
	
	\subsubsection{Context-aware Recognition\cite{context}}
	\label{subsec: context}
	Một quá trình nhận dạng biểu thức toán học chuẩn bao gồm 2 giai đoạn: giai đoạn đầu tiên là phân tách và nhận dạng ký hiệu\footnote{symbol segmentation and recognition} , giai đoạn thứ hai là phân tích cấu trúc\footnote{structure analysis}. Nhiều công trình nghiên cứu trước đây về nhận dạng biểu thức toán học cũng thực hiện theo phương pháp như vậy. Nhược điểm của những phương pháp dạng này là thực hiện hai quá trình trên một cách độc lập, do đó thông tin cấu trúc\footnote{structure information hay context information} của biểu thức không được đưa vào quá trình nhận dạng. Như vậy sẽ dẫn đến lỗi\cite{context}.
	
	WenHao He cùng các cộng sự của ông đã đề xuất một phương pháp dựa trên CNN, kết hợp với cách học đa nhiệm vụ\footnote{multi-task learning}, cố gắng kết hợp hai giai đoạn chuẩn của quá trình nhận dạng biểu thức toán lại với nhau.
	
	Phương pháp mà các ông đưa ra đảm bảo thông tin cấu trúc của biểu thức được đưa vào quá trình nhận dạng và thể hiện trong các ma trận đặc trưng\footnote{feature map}\cite{yanlecun}. \\
	Đối với các phương pháp trước, biểu thức phải được phân tách thành những ký hiệu rồi từng ký hiệu này mới được đưa qua bộ nhận dạng. Một số phương pháp phân tách ký hiệu thường được sử dụng như: phân tích thành phần liên thông\footnote{connected components}, cắt dựa trên các phép chiếu\footnote{projection cutting}\cite{segment}. Tuy nhiên với phương pháp mới này, cả ảnh của biểu thức toán học được đưa qua bộ nhận dạng, chính vì vậy mà thông tin cấu trúc của biểu thức được bảo toàn. \\
	%\vspace{5cm}
	
	Dưới đây là mô hình học của phương pháp này:\\
	
	\begin{figure}[!h]
		\centering
		\includegraphics[width=0.9\linewidth]{context_aware.png}
		\vspace{0.2cm}
		\caption{Mô hình học được đề xuất \cite{context}.}
		
	\end{figure}
	
	Ảnh đầu vào sẽ qua một số lớp tích chập, down-sampling và up-sampling để tạo ra một feature map. Feature map này sẽ được gửi đến ba nhiệm vụ, mỗi nhiệm sẽ tạo ra 1 feature map có cùng kích thước với feature map đầu vào. \\
	Giả sử một điểm $i$ được cho đặt tại toạ độ ($w_i$, $h_i$) của feature map được tạo ra bởi các nhiệm vụ. 
	\begin{itemize}
		\item \textbf{Nhiệm vụ phát hiện} (Dectection task) sẽ cho ra một con số $s$ thể hiện độ tin cậy rằng một ký hiệu được đặt tại $i$.
		\item \textbf{Nhiệm vụ hồi quy} (Regression task) cho ra một vec-tor 4 chiều {$x_1$, $y_1$, $x_2$, $y_2$} thể hiện thông tin về bounding box của ký hiệu được đặt tại $i$.
		\item\textbf{Nhiệm vụ nhận dạng} (Recognition task) gán nhãn cho ký hiệu đặt tại $i$ cùng với xác suất của nhãn đó. 
	\end{itemize}
	
	Như vậy nhiệm vụ phát hiện và hồi quy được thiết kế để định vị trí của ký hiệu trong biểu thức toán học, nhiệm vụ nhận dạng quyết định xem đó là ký hiệu gì.
	
	Phương pháp nhận dạng như trên có thể giải quyết cả những trường hợp là thách thức đối với các phương pháp phân tách và nhận dạng ký hiệu trước đây, cụ thể đó là vấn đề gom nhóm ký hiệu đối với các ký hiệu nhiều phần nhỏ, tách những ký hiệu bị dính nhau.
	
	\subsubsection{QAK\cite{qak}}
	QAK là tên dự án được thực hiện bởi nhóm sinh viên khoá 2011 cũng về đề tài nhận dạng biểu thức toán học.
	
	Phương pháp nhóm sinh viên này xây dựng dựa trên nghiên cứu chính từ hai công trình của Aderson\cite{anderson} và Zanibbi\cite{zanibbi}. Do đó, qua trình nhận dạng biểu thức toán học vẫn đi theo 2 bước chuẩn đó là phân tách ký hiệu và phân tích cấu trúc như đã trình bày ở mục \ref{subsec: context}. 
	
	Dưới đây là mô hình phương pháp mà nhóm đã đề xuất:
	%\vspace{3cm}
	
	\begin{figure}[!h]
		\centering
		\includegraphics[width=0.5\linewidth]{2011.png}
		\vspace{1cm}
		\caption{Quy trình nhận dạng.}
		
	\end{figure}
	
	\begin{itemize}
		\item Trong bước tiền xử lý, nhóm áp dụng một số kỹ thuật trong xử lý ảnh như: loại nhiễu, ảnh nhị phân,... để tăng cường chất lượng ảnh, hỗ trợ cho bước phân đoạn.
		\item Trong bước phân đoạn ảnh, nhóm dùng kỹ thuật chính là cắt theo hình chiếu\cite{segment} và phân tích thành phần liên thông\cite{segment} cho toán tử lấy căn. Mục tiêu của giai đoạn này là phân tách ảnh chứa biểu thức toán học ban đầu ra thành các mảnh ảnh, mỗi mảnh chỉ chứa 1 ký hiệu toán học. Ngoài ra, ở bước này một cấu trúc cây được xây dựng lưu thông tin của các mảnh ảnh, hỗ trợ cho quá trình phân tích ngữ pháp sau này.
		\item Ở bước nhận dạng, nhóm sinh viên khoá 2011 đã sử dụng một kiến trúc mạng tương tự Lenet-5\cite{yanlecun}.
		\item Với phân tích cú pháp, nhóm sử dụng tập luật \textbf{văn phạm phi ngữ cảnh} \footnote{Thuật ngữ tiếng Anh: Context-free grammar} do chính nhóm đề xuất để giới hạn kết quả đầu ra của quá trình nhận dạng, từ đó tăng khả năng nhận dạng đúng biểu thức. 
	\end{itemize}
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	\newpage
	\section{Mô hình đề xuất}
	
	\subsection{Tổng quan}
	
	Nhóm quyết định sử dụng mạng SSD\cite{liu2016ssd}để phát hiện các ký tự trong ảnh và sau đó sử dụng bộ phân tích cú pháp DRACULAE\cite{zanibbi} để sinh ra chuỗi Latex.
	
	\subsection{Phát hiện ký tự}
	
	\subsubsection{Mạng cơ sở}
	
	Về cấu trúc của SSD\cite{liu2016ssd}, nhóm đã sử dụng mạng VGG16\cite{simonyan2014very} cho phần mạng cơ sở. Cấu trúc của mạng VGG16\cite{simonyan2014very} gồm tổ hợp các lớp tích chập và lớp pooling xếp chồng lên nhau, ở cuối mạng có các lớp liên kết đầy đủ \footnote{Thuật ngữ tiếng Anh: Fully connected layer} để giảm kích thước tensor và cuối cùng là xuất ra vector có số chiều phù hợp (có số chiều bằng với số lớp đối tượng cần dự đoán).
	
	\begin{center}
		
		\centering
		\includegraphics[width=0.8\linewidth]{vgg16.png}
		\vspace{0.5cm}
		\captionof{figure}{Cấu tạo mạng VGG16\cite{simonyan2014very}}
	\end{center}
	
	Như hình vẽ bên trên, các lớp tích chập và lớp pooling được gom lại thành các cụm, sau hai đến ba lớp tích chập là một lớp pooling. Số kênh của tensor chạy trong mạng được nâng dần từ 64 lên 512 về phía cuối mạng. Khi đưa mạng cơ sở vào mạng SSD\cite{liu2016ssd}, các lớp liên kết đầy đủ sẽ được bỏ đi và bộ phận phân loại sẽ được chèn vào vị trí tương ứng. Khi đó, ta cần phải chuyển model của mạng VGG\cite{simonyan2014very} sang mạng SSD\cite{liu2016ssd}, phần này sẽ được đề cập chi tiết hơn trong phần hiện thực.
	
	\subsubsection{Thân mạng SSD\cite{liu2016ssd}}
	
	Khi tiếp hợp vào mạng SSD\cite{liu2016ssd}, các lớp liên kết đầy đủ của VGG16\cite{simonyan2014very} được lược bỏ, thay vào đó là những lớp tích chập, mô hình cụ thể của mạng SSD\cite{liu2016ssd} nhóm để xuất được thể hiện ở ảnh dưới.
	
	\begin{center}
		
		\centering
		\includegraphics[width=0.8\linewidth]{SSD_Layers.png}
		\vspace{0.5cm}
		\captionof{figure}{Sơ đồ các lớp trong mạng SSD\cite{liu2016ssd}}
	\end{center}
	
	Trong đó Khối VGG16 là phần mạng VGG16\cite{simonyan2014very} đã được lược bỏ các lớp liên kết đầy đủ. Các khối còn lại được thể hiện trong bảng sau:
	
	\begin{center}
		\begin{tabular}{||c | c | c | c | c | c ||} 
			\hline
			Khối & \makecell{ Số kênh \\ đầu vào } & \makecell{ Số kênh \\ đầu ra} & Kích thước nhân &  \makecell{ Chèn thêm \\ (Padding) } &  \makecell{ Bước \\ (Stride) } \\ [0.5ex] 
			\hline\hline
			Conv\_6 & 512 & 1024 & 3 & 1 & 1 \\ 
			\hline
			Conv\_7 & 1024 & 1024 & 3 & 6 & 1 \\ 
			\hline
			Conv\_8\_1 & 1024 & 256 & 1 & 0 & 1 \\ 
			\hline
			Conv\_8\_2 & 256 & 512 & 3 & 1 & 2 \\ 
			\hline
			Conv\_9\_1 & 512 & 128 & 1 & 0 & 1 \\ 
			\hline
			Conv\_9\_2 & 128 & 256 & 3 & 1 & 2 \\ 
			\hline
			Conv\_10\_1 & 256 & 128 & 1 & 0 & 1 \\ 
			\hline
			Conv\_10\_2 & 128 & 256 & 3 & 1 & 2 \\ 
			\hline
			Conv\_11\_1 & 256 & 128 & 1 & 0 & 1 \\ 
			\hline
			Conv\_11\_2 & 128 & 256 & 3 & 0 & 1 \\ 
			\hline
		\end{tabular}
		\captionof{table}{Cấu hình các lớp tích chập trong mạng SSD300\cite{liu2016ssd}}
	\end{center}
	
	Riêng khối Conv\_4 trong ảnh là lớp tích chập thứ 10 trong mạng VGG\cite{simonyan2014very}.\\
	
	Các lớp tích chập đều sử dụng hàm truyền là hàm ReLu, riêng ở sau các lớp Conv\_10\_1, Conv\_10\_2, Conv\_11\_1, Conv\_11\_2 thì có thêm một lớp dropout\cite{srivastava2014dropout} với hệ số dropout là 0.2.
	
	Các feature map được trích ra để thực hiện phát hiện, phân loại từ các mủi tên màu đỏ trên hình, cụ thể:
	
	\begin{itemize}
		\item Ngay sau khối tích chập - pooling 512 thứ nhất trong mạng VGG\cite{simonyan2014very} (hay sau lớp pooling của lớp tích chập thứ 10 của mạng VGG\cite{simonyan2014very} - hay Conv\_4).
		\item Sau các khối tích chập Conv\_7, Conv\_8, Conv\_9, Conv\_10, Conv\_11.
	\end{itemize}
	
	Đối với mạng SSD300\cite{liu2016ssd} , kích thước của các feature map ứng với số dự đoán được thể hiện ở bảng sau:
	
	\begin{center}
		\begin{tabular}{||c | c | c | c ||} 
			\hline
			\makecell{ Feature map \\ Sinh bởi } & \makecell{ Kích thước} & \makecell{Tỉ lệ \\ diện mạo } &  \makecell{ Số dự đoán } \\ [0.5ex] 
			\hline\hline
			Conv\_4 & $512 \times 38 \times 38$ & $ \{ 1, \frac{1}{2} , 2\} $ & 5776 \\ 
			\hline
			Conv\_7 & $1024 \times 19 \times 19$ & $ \{ 1, \frac{1}{2} , 2, \frac{1}{3}, 3\} $ & 2166 \\ 
			\hline
			Conv\_8 & $512 \times 10 \times 10$ &  $ \{ 1, \frac{1}{2} , 2, \frac{1}{3}, 3\} $ & 600 \\ 
			\hline
			Conv\_9 & $256 \times 5 \times 5 $ &  $ \{ 1, \frac{1}{2} , 2, \frac{1}{3}, 3\} $ & 150  \\ 
			\hline
			Conv\_10 & $256 \times 3 \times 3$ & $ \{ 1, \frac{1}{2} , 2\} $ & 36 \\ 
			\hline
			Conv\_11 & $256 \times 1 \times 1$ & $ \{ 1, \frac{1}{2} , 2\} $ & 4 \\ 
			\hline
		\end{tabular}
		\captionof{table}{Thông tin của các feature map trích được từ mạng SSD300\cite{liu2016ssd}}
	\end{center}
	
	Như vậy, ứng với mỗi ảnh, hệ thống sinh ra 8732 dự đoán. Tương ứng, bộ phận mã hóa của mạng SSD300\cite{liu2016ssd} cũng có những thông số:
	
	\begin{itemize}
		\item Danh sách kích thước feature map: (38, 19, 10, 5, 3, 1)
		\item Danh sách kích thước các ổ chuẩn (với $s_{min} = 0.2$ và $s_{max} = 0.9$): (30, 60, 111, 162, 213, 264, 315)
		\item Ngưỡng Jaccard\cite{Jaccard}: 0.5.
	\end{itemize}
	
	\subsubsection{Các thay đổi}
	
	Do bản chất mạng SSD300\cite{liu2016ssd} gặp rất nhiều khó khăn trong việc nhận dạng ký tự nhỏ do một số lý do:
	\begin{itemize}
		\item Trong quá trình kết hợp, các ô bọc "đáp án" kết hợp với ô chuẩn phải có chỉ số Jaccard\cite{Jaccard} lớn hơn 0.5, nhưng kích thước tối thiểu của ô chuẩn lại là $30 \times 30$ pixel, vì vậy nhiều ký tự nhỏ không thể kết hợp được (Trường hợp này xãy ra với hầu hết những ảnh có chữ nhỏ, ví dụ như ảnh dưới)
		\begin{center}
			\centering
			\includegraphics[resolution=300]{HMER_2017_TEST1_MINH_01_2A.png}
			\vspace{0.5cm}
			\captionof{figure}{Ảnh ví dụ chữ nhỏ (với kích thước thật)}
		\end{center}
		Khi không thể kết hợp được thì vùng ký tự đó được hiểu là phần nền, điều này gây bất lợi lớn cho quá trình huấn luyện do vùng ảnh không trống nhưng lúc là nền lúc lại được gắn nhãn.
		
		\item Nhiều ký tự có tỉ lệ diện mạo đặc biệt (Ví dụ như ký tự dấu $-$ trong phân số hoặc $\int$) cũng gặp nhiều khó khăn trong việc kết hợp do không đạt được ngưỡng Jaccard\cite{Jaccard}.
	\end{itemize}
	
	Vì vậy, nhóm đã sửa một số thông số để tìm cách giải quyết vấn đề trên, trong nhiều bộ thông số thì có 3 mô hình nổi bật.
	
	\subsubsection*{Giảm kích thước các ô chuẩn}
	
	Mô hình này dựa trên mô hình SSD300 nguyên thủy\cite{liu2016ssd}, chỉ chỉnh sửa kích thước các ô bọc thông qua chỉnh hai thông số $s_{min} = 0.08$ và $s_{max} = 0.5$, từ đó danh sách kích thước các ô chuẩn được thay đổi thành (9, 24, 54, 84, 114, 144, 174). So với mô hình nguyên thủy, mô hình này không thể kết hợp tốt các ký tự lớn (lớn hơn khoảng $200 \times 200$ pixel). Tuy vậy, đối với bài toán về phát hiện các ký tự trong một ảnh, thì kích thước các ký tự không thể quá lớn, nên những ký tự đặc biệt lớn như vậy có thể được xem xét ở độ ưu tiên thấp hơn.\\
	
	Việc thay đổi tham số ở mô hình này không làm ảnh hưởng lớn đến cấu trúc mạng cũng như quá trình mã hóa, giải mã. Số lượng dự đoán không thay đổi.\\
	
	Mục đích chính của thay đổi này là để quá trình kết hợp diễn ra tốt hơn khi kích thước của ô chuẩn nhỏ nhất là $9 \times 9$, điều này giúp cho những ký tự rất nhỏ vẫn có thể được kết hợp, tránh hiện tượng bỏ sót ký tự như mạng SSD300 nguyên thủy\cite{liu2016ssd}.
	
	\subsubsection*{Giảm kích thước các ô chuẩn và tăng kích thước ảnh đầu vào}
	
	Để có được mô hình này, nhóm cần phải có hai thay đổi so với mạng SSD300 nguyên thủy\cite{liu2016ssd}:
	\begin{itemize}
		\item Thay vì sử dụng ảnh $300 \times 300$ như nguyên thủy, ảnh sẽ được phóng to lên kích thước $500 \times 500$.
		\item Như ở mô hình đề xuất trước, nhóm thay đổi $s_{min} = 0.08$ và $s_{max} = 0.5$ từ đó thu được danh sách kích thước (15.0, 40, 80, 120, 160., 200, 240, 280).
	\end{itemize}
	
	Những thay đổi trên có làm thay đổi đến cấu trúc mạng SSD\cite{liu2016ssd}, khi tăng kích thước ảnh đầu vào nghĩa là kích thước của các feature map thu thập được cũng tăng lên, từ đó kéo số lượng dự đoán trong một ảnh tăng lên như bảng dưới.\\
	
	\begin{center}
		\begin{tabular}{||c | c | c | c ||} 
			\hline
			\makecell{ Feature map \\ Sinh bởi } & \makecell{ Kích thước} & \makecell{Tỉ lệ \\ diện mạo } &  \makecell{ Số dự đoán } \\ [0.5ex] 
			\hline\hline
			Conv\_4 & $512 \times 63 \times 63$ & $ \{ 1, \frac{1}{2} , 2\} $ & 15876 \\ 
			\hline
			Conv\_7 & $1024 \times 32 \times 32$ & $ \{ 1, \frac{1}{2} , 2, \frac{1}{3}, 3\} $ & 6144 \\ 
			\hline
			Conv\_8 & $512 \times 16 \times 16$ &  $ \{ 1, \frac{1}{2} , 2, \frac{1}{3}, 3\} $ & 1536 \\ 
			\hline
			Conv\_9 & $256 \times 8 \times 8 $ &  $ \{ 1, \frac{1}{2} , 2, \frac{1}{3}, 3\} $ & 384  \\ 
			\hline
			Conv\_10 & $256 \times 4 \times 4$ & $ \{ 1, \frac{1}{2} , 2\} $ & 144 \\ 
			\hline
			Conv\_11 & $256 \times 2 \times 2$ & $ \{ 1, \frac{1}{2} , 2\} $ & 64 \\ 
			\hline
		\end{tabular}
		\captionof{table}{Thông tin của các feature map trích được từ mạng SSD đã giảm kích thước ô chuẩn và tăng kích thước ảnh đầu vào}
	\end{center}
	
	Như vậy với mỗi ảnh, hệ thống sinh ra 24148 dự đoán, gấp gần 3 lần so với ảnh SSD300 nguyên thủy\cite{liu2016ssd}. Với những thay đổi này ô bọc thậm chí còn có thể kết hợp với những ô chuẩn nhỏ hơn, bên cạnh đó, mật độ các ô chuẩn cũng dày đặc hơn nhiều so với mạng SSD nguyên thủy\cite{liu2016ssd}.
	
	\subsubsection*{Giảm kích thước các ô chuẩn, tăng kích thước ảnh đầu vào và thêm lớp tích chập}
	
	Mô hình này thừa kế các thay đổi ở hai mô hình trước, tuy nhiên ở phần thân mạng SSD\cite{liu2016ssd}, nhóm đã gắn thêm 2 lớp tích chập ở cuối với các tham số: \\
	
	\begin{center}
		\begin{tabular}{||c | c | c | c | c | c ||} 
			\hline
			Khối & \makecell{ Số kênh \\ đầu vào } & \makecell{ Số kênh \\ đầu ra} & Kích thước nhân &  \makecell{ Chèn thêm \\ (Padding) } &  \makecell{ Bước \\ (Stride) } \\ [0.5ex] 
			\hline\hline
			Conv\_12\_1 & 256 & 128 & 1 & 0 & 1 \\ 
			\hline
			Conv\_12\_2 & 128 & 256 & 3 & 0 & 1 \\ 
			\hline
		\end{tabular}
		\captionof{table}{Cấu hình các lớp tích chập thêm vào mạng SSD300\cite{liu2016ssd} để được mạng SSD chỉnh sửa}
	\end{center}
	Hai lớp tích chập này cũng có hàm truyền là hàm relu và đi chung với lớp dropout\cite{srivastava2014dropout} với hệ số dropout là 0.2. \\
	
	Thay đổi này cũng làm thay đổi cấu trúc mạng:
	
	\begin{center}
		\begin{tabular}{||c | c | c | c ||} 
			\hline
			\makecell{ Feature map \\ Sinh bởi } & \makecell{ Kích thước} & \makecell{Tỉ lệ \\ diện mạo } &  \makecell{ Số dự đoán } \\ [0.5ex] 
			\hline\hline
			Conv\_4 & $512 \times 63 \times 63$ & $ \{ 1, \frac{1}{2} , 2\} $ & 15876 \\ 
			\hline
			Conv\_7 & $1024 \times 32 \times 32$ & $ \{ 1, \frac{1}{2} , 2, \frac{1}{3}, 3\} $ & 6144 \\ 
			\hline
			Conv\_8 & $512 \times 16 \times 16$ &  $ \{ 1, \frac{1}{2} , 2, \frac{1}{3}, 3\} $ & 1536 \\ 
			\hline
			Conv\_9 & $256 \times 8 \times 8 $ &  $ \{ 1, \frac{1}{2} , 2, \frac{1}{3}, 3\} $ & 384  \\ 
			\hline
			Conv\_10 & $256 \times 4 \times 4$ & $ \{ 1, \frac{1}{2} , 2\} $ & 160 \\ 
			\hline
			Conv\_11 & $256 \times 2 \times 2$ & $ \{ 1, \frac{1}{2} , 2\} $ & 40 \\ 
			\hline
			Conv\_12 & $256 \times 2 \times 1$ & $ \{ 1, \frac{1}{2} , 2\} $ & 10 \\ 
			\hline
		\end{tabular}
		\captionof{table}{Thông tin của các feature map trích được từ mạng SSD\cite{liu2016ssd} đã giảm kích thước ô chuẩn, tăng kích thước ảnh đầu vào và tăng số lớp tích chập}
	\end{center}
	
	Lớp Conv\_12 được thêm vào cuối mạng với mục đích tăng độ dài danh sách feature map đưa vào lớp Multibox, điều này giúp trong quá trình kết hợp, các ký tự lớn hơn có thể được kết hợp.
	
	\newpage
	\subsection{Phân tích cú pháp (Draculae Parser \cite{zanibbi})}
	
	Bộ phân tích cú pháp Draculae\cite{zanibbi} này có nhiệm vụ chuyển dữ liệu dự đoán là các ô bọc sang dữ liệu biểu thức toán học dạng latex. Trong quá trình phân tích cú pháp, biểu thức được lưu trữ dưới dạng cây BST\cite{zanibbi}\footnote{Viết tắt: baseline Syntax Tree: Cây cú pháp dựa trên đường cơ sở} là một cấu trúc cây dựa trên các đường cơ sở, các nhánh của cây thể hiện một phân vùng bên trên, bên dưới, ... của nút và là một phân vùng ảnh có đường cơ sở riêng và Lexed - BST\cite{zanibbi} là một cấu trúc cây tương tự như BST nhưng thay vì chỉ biểu thị vị trí bên trên, bên dưới thì cây biểu thị quan hệ phân số, chỉ số trên, chỉ số dưới, ...\\
	
	\begin{center}
		\centering
		\includegraphics[width=0.95\linewidth]{BST.png}
		\vspace{0.5cm}
		\captionof{figure}{Một cây BST\cite{zanibbi}}
	\end{center}	
	
	\begin{center}
		\centering
		\includegraphics[width=0.85\linewidth]{lexBST.png}
		\vspace{0.5cm}
		\captionof{figure}{Một cây Lexed - BST\cite{zanibbi}}
	\end{center}
	
	\subsubsection{Sinh cây BST\cite{zanibbi}}
	
	Đây là giai đoạn phức tạp nhất và cũng là quan trọng nhất, ở giai đoạn này, dữ liệu đầu ra từ mạng SSD\cite{liu2016ssd} là danh sách các ô bọc sẽ được phân tích và xây dựng một cây BST\cite{zanibbi}. Công việc này có thể được phân ra thành bốn công đoạn: Tìm ký tự chủ đạo, xác định những ký tự trên đường cơ sở, tái phân vùng và xử lý nút con\\
	
	Trước khi tiến hành sinh cây, ta cần phải phân loại các ký tự vào những thể loại khác nhau, điều này có mục đích giúp xác định vị trí trọng tâm tốt hơn, xác định được vùng ảnh gắn với chỉ số trên, chỉ số dưới và giúp phân biệt một số loại ký tự có thể có cấu trức đặc biệt trong biểu thức (ví dụ như ký tự $\sum$ thì có thể có ký tự nằm trên và bên dưới, nhưng ký tự $sin$ thì gần như không bao giờ có). Như Zanibbi đã đề xuất cho Draculae\cite{zanibbi}, các ký tự được phân vào các lớp như bảng dưới:
	
	\begin{center}
		\begin{tabular}{||c | c | c c c c ||} 
			\hline
			Lớp ký tự & Tung độ trọng tâm & Bên dưới & Bên trên & Chỉ số dưới & Chỉ số trên \\ [0.5ex] 
			\hline\hline
			\makecell{Non-Script \\ Các ký tự phép tính\\ $(+, -, \rightarrow, ... )$} & $\frac{1}{2}H$ & $\frac{1}{2}H$ & $\frac{1}{2}H$ & - & - \\ 
			\hline
			\makecell{Open Bracket \\ Ký tự mở ngoặc \\ ( } & $cH$ & $min(Y)$ & $max(Y)$ & - & - \\
			\hline
			\makecell{Root \\ Ký tự căn \\ $\sqrt{}$ } & $cH$ & $min(Y)$ & $max(Y)$ & $tH$ & $H - tH$ \\
			\hline
			\makecell{Variable Range \\ Ký tự có thể viết \\ ở trên hoặc dưới \\ $\sum$, $\int$, $\lim$ ... } & $\frac{1}{2}H$ & $tH$ & $H-tH$ & $tH$ & $H- tH$ \\
			\hline
			\makecell{Ascender \\ Ký tự nổi lên \\ A..Z, 0..9, b,d,f ... } & $cH$ &  $tH$ & $H-tH$ & $tH$ & $H- tH$ \\
			\hline
			\makecell{Descender \\ Ký tự chìm xuống \\ g, p, y, j, ..., b,d,f ... } & $H - cH$ &  $\frac{1}{2}H + t\frac{1}{2}H$ & $H-t\frac{1}{2}H$ & $\frac{1}{2}H + t\frac{1}{2}H$ & $H-t\frac{1}{2}H$ \\ 
			\hline
			\makecell{Centered \\ Ký tự trung tâm \\ o, n, u, \}, ) ... } & $\frac{1}{2}H$ &  $tH$ & $H-tH$ & $tH$ & $H- tH$
			\\ \hline
			
			
		\end{tabular}
		\captionof{table}{Bảng phân lớp các ký tự cần nhận diện và các ngưỡng xác định phân vùng con}
		
	\end{center}
	
	Trong đó:
	\begin{itemize}
		\item Các cột thứ hai trở đi là tọa độ của một số điểm, ngưỡng đặc biệt tính từ góc trái bên dưới của ký tự. Hệ trục tọa độ có trục tung hướng lên và trục hoành hướng sang phải. Cột "Tung độ trọng tâm" thể hiện tung độ y của trọng tâm của ký tự, cột bên dưới và bên trên thể hiện ngưỡng trên và ngưỡng dưới của ký tự, các ký tự vượt ngoài ngưỡng đó sẽ được xem là nằm bên trên hoặc nằm bên dưới ký tự đang xét (Ví dụ như một ký tự nào đó có tung độ trọng tâm lớn hơn $max(Y)$ của môt ký tự thuộc lớp $Root$ thì sẽ được xem là nằm bên trên). Cột chỉ số trên, chỉ số dưới thể hiện ngưỡng để được phân vào vùng chỉ số trên, chỉ sô dưới. Riêng hai lớp Non-scipt và Open Bracket có giá trị hai cột này không xác định là do những ký tự của lớp này không có chỉ số trên, dưới.
		\item $H$ là chiều cao của ký tự.
		\item $c$ (Viết tăt của centroid ratio): là tham số để xác định trọng tâm cho một số ký tự đặc biệt (ví dụ như các ký tự ngoặc hoặc chìm xuống dưới), tùy người viết chữ có thể có những giá trị phù hợp khác nhau.
		\item $t$ Là ngưỡng cho chỉ số trên, dưới và chỉ phần bên trên, bên dưới. Tham số này biểu thị sự nhạy cảm đối với những ký tự trên dưới, tham số này càng lớn thì các ký tự khi được phân tích vị trí càng dễ được xếp vào chỉ số trên, chỉ số dưới.
	\end{itemize}
	
	Bảng trên thể hiện quy tắc để kiểm tra hai ký tự có vị trí tương đối như thế nào với nhau, cụ thể:
	\begin{itemize}
		
		\item B chứa trong A (dành cho trường hợp ký tự căn: $\sqrt{}$) khi B có tung độ nằm trong khoảng từ ngưỡng chỉ số dưới đến ngưỡng chỉ số trên của A và hoành độ trọng tâm của B nằm trong khoảng $(Min(X_B), Max(X_B)$.
		
		\item A và B liền kề nếu như trọng tâm của B có tung độ nằm trong khoảng từ ngưỡng chỉ số dưới đến ngưỡng chỉ số trên của A và hoành độ trọng tâm của B lớn hơn $Max(X_A)$.
		
		\item B là chỉ số trên của A nếu như trọng tâm của B lớn hơn ngưỡng chỉ số trên của A.
		
		\item B là ký tự phân số thống trị A khi trọng tâm của A có hoành độ nằm trong khoảng $(Min(X_B), Max(X_B)$
		
	\end{itemize}
	
	Trước khi tiến hành sinh cây BST, danh sách ô bọc cần phải được sắp xếp theo chiều tăng dần hoành độ của mép phải ô bọc $x$ (hay cụ thể hơn là $min(x)$). \\
	
	\subsubsection*{Tìm ký tự chủ đạo}
	
	Trong hầu hết trường hợp, ký tự chủ đạo là ký tự nằm bên trái nhất, tuy vậy, ta vẫn cần phải kháng được những trường hợp người dùng viết chữ không chuẩn gây thụt ra ngoài, hoặc những ký tự có dạng như:
	
	$$ \sum^{n = 100000} a $$
	Thì ký tự chủ đạo là $\sum$ nhưng ký tự bên trái nhất lại là $n$, Draculae\cite{zanibbi} được thiết kế để có thể chống lại những trường hợp như vậy.\\
	
	
	Để tìm ký tự chủ đạo, ta cần thực hiện những công đoạn sau:
	\begin{itemize}
		\item Trước hết, ta tìm ký tự nằm bên trái nhất.
		\item Kiếm tra ký tự đó có phải là Variable Range. Nếu đúng thì ta kiểm tra xem ký tự đó có bị thống trị bởi một phân số hay không, nếu có thì ký tự chủ đạo là ký tự phân số, nếu không thì ký tự chủ đạo là ký tự Variable Range vừa tìm được. Nếu ký tự vừa tìm được không phải là Variable Range, thì ta tìm kiếm ký tự Variable Range nằm bên trái nhất và sang bước tiếp theo.
		
		\item Nếu không còn ký tự Variable Range nào khác, thì ký tự bên trái nhất vừa tìm được ở bước trên được kiểm tra bị thống trị bởi phân số hay không và trả về ký tự chủ đạo (ký tự đó hoặc ký tự phân số). Nếu còn một ký tự Variable Range khác trong biểu thức, ta tiếp tục với bước kế tiếp.
		
		\item Ta kiểm tra xem ký tự Variable Range khác đó có ký tự nào nằm liền kề bên trái không. Nếu không thì tự Variable Range được kiểm tra xem có bị thống trị bởi ký tự phân số hay không và chọn ký tự chủ đạo ký tự phù hợp. Nếu tồn tại ký tự liền kề bên trái, thì ký tự bên trái nhất được kiểm tra có bị thống trị bởi phân số không và chọn ký tự chủ đạo phù hợp.
		
	\end{itemize}
	
	\subsubsection*{Xác định ký tự trên đường cơ sở}
	
	Sau khi đã có được ký tự chủ đạo, ta cần phải tìm những ký tự liền kề theo chiều ngang với ký tự vừa tìm được, những ký tự này chính là ký tự trên đường cơ sở. Để xác định các ký tự trên đường cơ sở, ta lấy ký tự chủ đạo vừa xác định được để xét:
	
	\begin{enumerate}
		\item Ta phần vùng các ký tự nằm ở vùng bên trên, bên dưới, góc trên bên trái và góc dưới bên trái (không phân vùng các ký tự nằm bên phải) vào nút con của nút đang xét.
		\item Nếu như ký tự đang xét thuộc lớp Non-script, ký tự đó được đánh dấu nằm trên đường chủ đạo, ta quay lại tìm ký tự chủ đạo trong các ký tự còn lại và xác định các ký tự trên đường cơ sở với ký tự chủ đạo đó.
		\item Ta kiểm tra danh sách các ký tự còn lại xem có ký tự nào liền kề bên phải với ký tự đang xét hay không, nếu có, ta kiểm tra ký tự đó có bị thống trị bởi ký tự khác hay không và quay lại bước 1 với ký tự được xét là ký tự thống trị nhất (hoặc chính ký tự liền kề nhất vừa tìm được đối với trường hợp nó không bị thống trị bởi ký tự nào).
		\item Nếu hệ thống chạy đến bước này thì có nghĩa là trong các ký tự còn lại, không còn ký tự nào liền kề với ký tự đang xét, vì vậy ta tiến hành phân vùng đưa các ký tự còn lại vào nút con góc trên bên phải (chỉ số trên) và góc dưới bên phải (chỉ số dưới) của nút đang xét.
	\end{enumerate}
	
	Sau khi thực hiện bước này lần đầu tiên, ta thu được một cây có ba tầng, tầng đầu chứa nút gốc, tầng thứ hai chứa các ký tự nằm trên đường cơ sở, tầng thứ ba chứa các nút con của các nút chứa ký tự nằm trên đường cơ sở, các nút con này có thể chứa một hoặc nhiều ký tự, chưa là một cây.
	
	\subsubsection*{Tái phân vùng}
	Ở bước trước, nút con được phân vào vùng góc trên bên trái và góc dưới bên trái, điều này không có ý nghĩa đối với ngữ nghĩa của biểu thức toán học và khó khăn trong việc sinh cây Lexed BST\cite{zanibbi} sau này. Vì vậy ở bước này, các nút con sẽ được thay đổi vị trí cho phù hợp với ngữ nghĩa của biểu thức. Cụ thể:
	
	\begin{itemize}
		\item Các nút con thuộc vùng góc trên bên trái và góc dưới bên trái sẽ được phân vùng vào vùng góc trên bên phải và góc dưới bên phải của ký tự trước đó.
		\item Riêng đối với các ký tự Variable Range, hệ thống thực hiện thêm bước kiểm tra sự liền kề đối với những ký tự trong vùng con để phân vùng phù hợp.
	\end{itemize}
	
	\iffalse
	, chương trình sẽ kiểm tra từng cặp ký tự liền kề theo thứ tự từ trái sang phải, ta gọi ký tự bên trái là $A$ và ký tự bên phải là $B$:\\
	
	\begin{itemize}
		\item Nếu $B$ không thuộc lớp Variable Range, và $B$ không có nút con ở vùng bên trên, ta gắn nút góc trên bên trái của ký tự $B$ vào nút góc trên bên phải (chỉ số trên) của $A$. 
		\item Nếu $B$ thuộc lớp Variable Range thì ta sẽ phân vùng những ký tự liền kề với ký tự đầu tiên trong nút con góc trên bên trái của $B$ vào vùng bên trên của $B$. 
		\item Nếu $A$ thuộc lớp Variable Range thì ta phải tiến hành gộp các vùng góc trên bên trái, bên trên và góc trên bên phải thành một vùng bên trên duy nhất.
	\end{itemize}
	
	Với một số biểu thức đặc biệt hoặc nhập nhằng thì việc phân vùng sẽ không chính xác, để khắc phục điều này, ta cần phải có thêm công đoạn hậu xử lý.\\
	
	\fi
	
	\subsubsection*{Xử lý nút con}
	
	Tới bước này, ta đã có một cây có ba tầng với tầng thứ hai có phân vùng nút con khá chuẩn xác. Nhiệm vụ bây giờ là phải tiếp tục phân vùng cho các nút con của các ký tự trên đường cơ sở. Việc này được thực hiện bằng cách xem từng nút con là từng vùng ảnh mới riêng biệt và thực hiện lại ba bước trên để thu được các cây con. \\
	
	Sau quá trình này, ta thu được một cây BST biểu thị vị trí tương đối giữa các nút. Cây này tiếp tục được đi qua [Lexical Pass] để thu được Lexed - BST\cite{zanibbi}.
	
	\subsubsection{Sinh cây Lexed - BST\cite{zanibbi}}
	
	Sau khi đã thu được cây BST từ danh sách các ô bọc, nhiệm vụ còn lại là không quá phức tạp. Trước khi tạo được chuỗi Latex, ta cần phải sinh ra được một cây Lexed - BST\cite{zanibbi}, cây này chứa các thông tin như "nhóm ký tự" và cấu trúc biểu thức:
	
	\begin{itemize}
		\item Nhóm ký tự: Ban đầu, các ký tự được gom thành từng nhóm có nghĩa (Ví dụ các ký tự "s", "i", "n" thì sẽ được gộp lại thành một ký tự "sin" duy nhất.
		\item Ta sử dụng các luật khác nhau để sinh ra cây Lexed - BST\cite{zanibbi}.
	\end{itemize}
	
	\subsubsection*{Luật sinh}
	
	
	Để chuyển từ cây BST\cite{zanibbi} sang cây lexed - BST\cite{zanibbi}, nhóm có đề xuất một số luật sinh: \\
	Gọi ký tự đang xét là $A$
	\begin{itemize}
		\item Nếu cây BST $B$ nằm trong nút con góc phải bên dưới của $A$ thì sinh ra một nút sub(A, B)
		\item Nếu cây BST $B$ nằm trong nút con góc phải bên trên của $A$ thì sinh ra một nút sup(A, B)
		\item Nếu cây BST $B$ nằm trong nút con bên trong của $A$ và $A$ là ký tự căn ($\sqrt{}$) thì sinh ra một nút sqrt(B)
		\item Nếu $A$ có nút con bên trên hoặc bên dưới (hoặc cả hai), thì tùy thuộc vào ký tự $A$ mà ta sinh ra các nút khác nhau (Ví dụ như các ký tự $\sum$, $\lim$, $\prod$ , $\int$, $\rightarrow$ và quan trọng nhất là dấu gạch ngang trong phân số)
		
	\end{itemize}
	
	Sau khi sinh được cây Lexed - BST\cite{zanibbi}, hệ thống sẽ duyệt qua cây theo chiều tiền thứ tự để sinh mã Latex
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\newpage
	\section{Hiện thực, đánh giá}
	
	Để xây dựng hệ thống nhận diện biểu thức toán học viết tay, nhóm cần hoàn thành ba công việc chính bao gồm thu thập dữ liệu, huấn luyện mạng SSD và xây dựng chương trình sinh mã latex.
	
	\subsection{Chuẩn bị dữ liệu}
	Việc chuẩn bị dữ liệu bao gồm xây dựng tập ký tự viết tay thường dùng trong Toán học và xây dựng bộ những biểu thức Toán học viết tay sử dụng những ký hiệu đó.
	\subsubsection{Xây dựng tập ký tự}
	Như đã đề cập trong chương 1, nhóm sử dụng lại tập ký hiệu Toán viết tay bao gồm chữ cái, chữ số, các ký hiệu Hy Lạp của nhóm sinh viên khoá 2011\cite{qak}.\\
	Một số thông tin về tập dữ liệu\footnote{Sử dụng thông tin được nêu trong luận văn \cite{qak}.}:
	\begin{itemize}
		\item Số người tham gia: khoảng 20
		\item Số lượng ký hiệu: 46197
		\item Số lượng nhãn: 88
		\item Các ký hiệu trong tập dữ liệu: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f, g, h, i,
		j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, (, ), +, -, *, /, =, $\int$, $\alpha$, $\beta$, $\gamma$, $\delta$, $\epsilon$, $\theta$, $\lambda$, $\mu$, $\pi$, $\rho$, $\sigma$, $\phi$, $\omega$, $\Delta$, $\Pi$, $\Sigma$, $\Phi$, $\Omega$.
	\end{itemize}
	Tuy nhiên, nhóm đã bổ sung thêm 18 nhãn ký hiệu vào tập dữ liệu này dựa trên cách thu thập được giới thiệu trong luận văn của nhóm sinh viên khoá 2011\cite{qak}.\\
	Thông tin mô tả tập ký hiệu được sử dụng cho đề tài:
	\begin{itemize}
		\item Số người tham gia: 36
		\item Số lượng ký hiệu: 52353
		\item Số lượng nhãn: 106
		\item Các ký hiệu trong tập dữ liệu: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, (, ), +, -, *, /, =, $\int$, $\alpha$, $\beta$, $\gamma$, $\delta$, $\epsilon$, $\theta$, $\lambda$, $\mu$, $\pi$, $\rho$, $\sigma$, $\phi$, $\omega$, $\Delta$, $\Pi$, $\Sigma$, $\Phi$, $\Omega$, $\sin$, $\cos$, $\tan$, $\log$, $\lim$, $\surd$, $\rightarrow$, $\geq$, $\leq$, $\forall$, $\exists$, $\in$, !, ., $\ldots$, $\div$, $\neq$, $\infty$.
		
	\end{itemize}
	\subsubsection{Xây dựng tập biểu thức}
	Để phục vụ quá trình huấn luyện của mạng SSD được nêu trong Chương 4, ngoài tập ký tự nhóm cần phải xây dựng thêm tập ảnh các biểu thức Toán học viết tay.\\
	\subsubsubsection{Quá trình thu thập dữ liệu bao gồm các công việc:}
	\begin{itemize}
		\item Tạo biểu mẫu để thu dữ liệu. Biễu mẫu này có 6 hàng và 2 cột như hình bên dưới. 
		\begin{center}
			\centering
			\includegraphics[width=0.8\linewidth]{getExp}
			\vspace{0.5cm}
			\captionof{figure}{Biểu mẫu để thu thập dữ liệu.}
		\end{center}
		\item Chuẩn bị bộ biểu thức làm gợi ý cho người viết. Các biểu thức này được sao chép từ tập dữ liệu CROHME 2014\cite{crohme}. 
		
		\begin{center}
			\centering
			\includegraphics[width=0.9\linewidth]{Exp_sample1}
			\vspace{0.5cm}
			\captionof{figure}{Ví dụ mẫu biểu thức gợi ý cho người viết.}
		\end{center}
		\item Người tham gia viết sẽ nhận được biểu mẫu và công thức gợi ý. Sau đó họ sẽ viết lại những công thức này lên tờ biểu mẫu bằng chính nết chữ thường ngày của họ. 
		\begin{center}
			\centering
			\includegraphics[width=0.8\linewidth]{Exp_sample_vd}
			\vspace{0.5cm}
			\captionof{figure}{Ví dụ một mẫu thu thập được từ người tham gia viết.}
		\end{center}
		\item Tập hợp lại các biểu mẫu sau khi cho người tham gia viết rồi mang đi scan. Sau đó xử lý qua một đoạn mã Matlab\cite{qak}\footnote{Đoạn mã này đã được chỉnh sửa để phù hợp với hình dạng mẫu lấy biểu thức của nhóm.} để từ một ảnh gồm nhiều biểu thức thu được ảnh chỉ chứa đúng một biểu thức như hình bên dưới.
		\begin{center}
			\centering
			\includegraphics[width=0.5\linewidth]{EXP_2017_072_2A.png}
			\vspace{0.5cm}
			\captionof{figure}{Ví dụ một ảnh thu được sau khi xử lý biểu mẫu đã qua scan bằng đoạn mã Matlab.}
		\end{center}
		\item Thực hiện gán nhãn và xác định bounding box cho từng ký hiệu trong ảnh thu được từ bước trên bằng công cụ do nhóm tự thực hiện với giao diện như hình bên dưới. Công cụ này cho phép tải ảnh, xác định bounding boxes cho các đối tượng trong ảnh bằng cách kéo thả chuột từ góc trên bên trái đến góc dưới bên phải của từng đối tượng và nhập nhãn cho mỗi đối tượng đó. Quá trình này kết thúc sẽ thu được file với định dạng .txt lưu thông tin cần thiết về dữ liệu cho quá trình huấn luyện và kiểm tra. 
		\begin{center}
			\centering
			\includegraphics[width=0.65\linewidth]{tool}
			\vspace{0.5cm}
			\captionof{figure}{Giao diện công cụ hỗ trợ quá trình gán nhãn và xác định bounding boxes. }
		\end{center}
	\end{itemize}
	\subsubsubsection{Thông tin mô tả tập dữ liệu biểu thức:}
	\begin{itemize}
		\item Số người tham gia: khoảng 88 
		\item Số lượng ảnh\footnote{Mỗi ảnh chỉ chứa một biểu thức.}:  2256. Trong đó có 1746 ảnh dùng cho training, 138 ảnh dùng cho quá trình validation và 372 ảnh để test.
		\item Số loại biểu thức: khoảng 552
		\item Tổng số ký tự trong tập huấn luyện: 13697
		\item Tổng số ký tự trong tập kiểm tra: 2237
		\item Số  người gán nhãn: 3
	\end{itemize}
	Hình minh hoạ cho sự phận phối số lượng ký tự trong từng nhãn đối với tập huấn luyện và tập kiểm tra.
	\begin{figure}
		\includegraphics[width=0.475\linewidth]{train_statis.png}
		\hfill
		\includegraphics[width=0.475\linewidth]{test_statis.png}
		\vspace{0.5cm}
		\captionof{figure}{Sự phân phối ký tự theo từng nhãn đối với tập huấn luyện và tập kiểm tra.}
	\end{figure}
	\newpage
	\subsection{Hiện thực hệ thống}
	
	\subsubsection{Quá trình tiền huấn luyện}
	Như đã trình bày ở trên, mạng SSD\cite{liu2016ssd} mà nhóm lựa chọn có sử dụng mạng cơ sở là VGG16\cite{simonyan2014very}, đây là một mạng phân lớp\footnote{Thuật ngữ tiếng anh: Classification}. Để đạt được kết quả huấn luyện cho mạng SSD\cite{liu2016ssd} tốt hơn, tác giả đã khuyến cáo sử dụng phương pháp học chuyển tiếp\footnote{Thuật ngữ tiếng anh: Transfer Learning}\cite{liu2016ssd}
	
	\subsubsection{Học chuyển tiếp}
	
	Để thực hiện phương pháp này, ta cần phải chuẩn bị một tập dữ liệu riêng gồm các ảnh kích thước $32 \times 32$. Các ảnh này được lấy từ tập huấn luyện của đề tài QAK.\\
	
	Khi đã thu được một mô hình phù hợp (Huấn luyện tập tiền huấn luyện đã hội tụ), nhiệm vụ kế tiếp là ta phải chuyển các tham số đã học được sang một mô hình của mạng SSD\cite{liu2016ssd}.\\
	
	Quá trình này không quá phức tạp, nhóm đã viết một đoạn mã giúp tạo một mô hình mạng SSD rỗng, sau đó gán tham số từ mô hình mạng VGG16\cite{simonyan2014very} vừa thu được sang mô hình mạng SSD mới. Ta bỏ qua các lớp liên kết đầy đủ do phần này đã được lược bỏ, lớp pooling cũng được bỏ qua do lớp này không có tham số. \\
	
	Sau khi đã thu được mô hình mạng SSD, ta có thể bước tiếp đến công đoạn huấn luyện mạng SSD.
	\subsubsection{Config SSD, giới thiệu 4 model ở đây thay vì ở phương pháp đề xuất.}
	
	\subsection{Xây dựng bản thử nghiệm}
	
	Khi đã thu được mô hình hoàn thiện của SSD, nhóm xây dựng một bản thử nghiệm bằng python. Giao diện khá đơn giản, người dùng chỉ việc chọn thư mục chứa ảnh, sau đó chọn ảnh cần nhận diện. Chương trình sẽ xử lý và đưa ra 3 ảnh gồm ảnh gốc ban đầu, ảnh thể hiện các ô bọc mà mạng dự đoán và ảnh biểu thức toán học được tạo ra từ đoạn mã Latex.
	
	\begin{center}
		
		\centering
		\includegraphics[width=0.8\linewidth]{demoImg.png}
		\vspace{0.5cm}
		\captionof{figure}{Giao diện bản thử nghiệm}
	\end{center}
	\subsection{Kết quả}
	\subsubsection{Quy ước}
	
	Trong mục phương pháp đề xuất, nhóm đã đưa ra bốn mô hình, bốn mô hình này sẽ được đánh số như sau:
	\begin{itemize}
		\item Mô hình I: Mạng SSD300 nguyên thủy\cite{liu2016ssd}.
		\item Mô hình II: Mạng SSD300\cite{liu2016ssd} với thay đổi giảm kích thước các ô chuẩn.
		\item Mô hình III: Mạng SSD300\cite{liu2016ssd} với thay đổi giảm kích thước các ô chuẩn và tăng ảnh đầu vào lên $500 \times 500$.
		\item Mô hình IV: Mạng SSD300\cite{liu2016ssd} với thay đổi giảm kích thước các ô chuẩn, tăng kích thước ảnh đầu vào và tăng thêm một số lớp tích chập.
	\end{itemize}
	
	\subsubsection{Định tính giữa bốn mô hình}
	\subsubsubsection{Quá trình kết hợp}
	Nhóm đã giảm kích thước các ô chuẩn, đồng thời phóng to ảnh đầu vào, một phần mục đích là để quá trình kết hợp có thể thực hiện tốt hơn đối với các ký tự nhỏ. Công việc này thật sự đã cải thiện được quá trình kết hợp khi kích thước tối thiểu của ô bọc "đáp án" được cải thiện một cách đáng kể:
	
	\begin{center}
		\begin{tabular}{||c | c | c | c | c||} 
			\hline
			Mô hình & \makecell{  I } & \makecell{ II} & III &  \makecell{ IV}  \\ [0.5ex] 
			\hline
			Ô bọc vuông & $22 \times 22$ & $12 \times 12$ & $7 \times 7$ & $7 \times 7$ \\
			\hline
			Ô bọc có tỉ lệ 1 : 2 & $16 \times 32$ & $16 \times 32$ & $5 \times 10$ & $5 \times 10$ \\
			\hline
		\end{tabular}
		\captionof{table}{Kích thước ô bọc "đáp án" nhỏ nhất mà mạng có thể kết hợp với ô chuẩn được của bốn mô hình đề xuất. (Đơn vị tính: Điểm ảnh - Pixel) }
	\end{center}
	
	\subsubsubsection{Quá trình nhận diện}
	
	Kết quả của mô hình II không tốt, về mặt lý thuyết thì khi giảm kích thước các ô bọc, khả năng nhận diện các ký tự nhỏ sẽ tốt hơn, tuy nhiên khi áp dụng cho mô hình II, mạng đã gặp một số vấn đề: 
	
	\begin{itemize}
		\item Giảm kích thước ô bọc sẽ khiến cho các ký tự lớn "bị hổng", do các ô bọc quá lớn khi tính chỉ số Jaccard\cite{Jaccard} với các ô chuẩn quá nhỏ sẽ không đủ ngưỡng, vì vậy mạng không thể kết hợp được các ký tự lớn, từ đó mạng cũng không thể nhận diện các ký tự lớn.
		\item Mạng có thể nhận diện được các ký tự nhỏ hơn, tuy nhiên các ký tự này cũng không đủ nhỏ để bao phủ phần lớn các ký tự nhỏ có trong tập dữ liệu.
	\end{itemize}

	
	\begin{center}
		\centering
		\includegraphics[width=0.775\linewidth]{compare_1.png}
		\vspace{0.5cm}
		
		\captionof{figure}{Kết quả giữa mô hình I và mô hình II (1).}
	\end{center}
	
	\begin{center}
		\centering
		\includegraphics[width=0.775\linewidth]{compare_2.png}
		\vspace{0.5cm}
		
		\captionof{figure}{Kết quả giữa mô hình I và mô hình II (2).}
	\end{center}
	
	Như kết quả ở trên, mô hình II đưa ra dự đoán về ký tự nhỏ tốt hơn mô hình I một ít, nhưng kết quả vẫn còn rất tệ. Tuy vậy đối với những ký tự lớn, mô hình II tỏ ra yếu hơn so với mô hình I.
	
	\begin{center}
		\centering
		\includegraphics[width=0.775\linewidth]{compare_3.png}
		\vspace{0.5cm}
		
		\captionof{figure}{Kết quả giữa mô hình I và mô hình II (3).}
	\end{center}
	
	\begin{center}
		\centering
		\includegraphics[width=0.775\linewidth]{compare_4.png}
		\vspace{0.5cm}
		
		\captionof{figure}{Kết quả giữa mô hình I và mô hình II (4).}
	\end{center}
	
	Ngược lại với mô hình II, kết quả của mô hình III và IV khá tốt, hệ thống đã có thể nhận diện nhiều ký tự rất nhỏ và tương đối chuẩn xác.
	
	\begin{center}
		\centering
		\includegraphics[width=0.775\linewidth]{compare_5.png}
		\vspace{0.5cm}
		
		\captionof{figure}{Kết quả giữa mô hình I và mô hình IV (1).}
	\end{center}
	
	\begin{center}
		\centering
		\includegraphics[width=0.775\linewidth]{compare_6.png}
		\vspace{0.5cm}
		
		\captionof{figure}{Kết quả giữa mô hình I và mô hình IV (2).}
	\end{center}
	
	Đặc biệt, có nhiều biểu thức có ký tự rất nhỏ nhưng mô hình IV đã làm việc rất tốt:
	
	\begin{center}
		\centering
		\includegraphics{compare_7.png}
		\vspace{0.5cm}
		\captionof{figure}{Ảnh kết quả của mô hình IV(với kích thước thật)}
	\end{center}
	
	Tuy vậy, mô hình IV hầu như không thua kém mô hình I trong việc nhận diện ký tự lớn, một số ký tự mô hình I nhận diện được nhưng mô hình IV không thể và ngược lại. Để giải quyết phần này, nhóm có đề xuất một hướng đi trong tương lai để cải thiện khả năng nhận diện ký tự lớn này.
	
	\begin{center}
		\centering
		\includegraphics[width=0.775\linewidth]{compare_8.png}
		\vspace{0.5cm}
		
		\captionof{figure}{Kết quả giữa mô hình I và mô hình IV (3).}
	\end{center}
	
	\begin{center}
		\centering
		\includegraphics[width=0.775\linewidth]{compare_9.png}
		\vspace{0.5cm}
		
		\captionof{figure}{Kết quả giữa mô hình I và mô hình IV (4).}
	\end{center}
	
	Riêng đối với mô hình III và mô hình IV, hai mô hình này có chênh lệch rất nhỏ trong khả năng dự đoán, cần phải định lượng để phân định.
	
	\subsubsection{Định lượng}
	Trong quá trình thực hiện, nhóm đã xây dựng 4 mô hình huấn luyện dựa trên những thay đổi của 3 yếu tố sau:
	\begin{itemize}
		\item Kích thước ảnh đầu vào của mạng SSD.
		\item Kích thước default boxes.
		\item Số lượng default boxes.
	\end{itemize}
	Thông tin cụ thể như bảng bên dưới.
	\begin{center}
		\begin{tabular}{||c | c | c | c | c||} 
			\hline
			Mô hình & \makecell{  I } & \makecell{ II} & III &  \makecell{ IV}  \\ [0.5ex] 
			\hline\hline
			Kích thước ảnh đầu vào& 300x300 & 300x300 & 500x500 & 500x500 \\ 
			\hline
			Kích thước default boxes& \makecell{min\_ratio: 20\\max\_ration: 90\\min\_scale: 0.1} &  \makecell{min\_ratio: 8\\max\_ratio: 50\\min\_scale: 0.03} & \makecell{min\_ratio: 8\\max\_ratio: 50\\min\_scale: 0.03}  & \makecell{min\_ratio: 8\\max\_ratio: 50\\min\_scale: 0.03}  \\ 
			\hline
			Số lượng default boxes & 8732 & 8732 & 24148 & 24024\\
			\hline
		\end{tabular}
		\captionof{table}{Sự khác nhau giữa 4 mô hình thử nghiệm.}
	\end{center}
	Điều kiện đánh giá:
	\begin{itemize}
		\item Cùng một tập ảnh kiểm tra với 372 ảnh. Phân phối số lượng ký tự trên từng nhãn của tập ảnh kiểm tra được thể hiện trong Hình 16.
		\item Độ đo sử dụng: mAP
		\item Điều kiện máy chạy đánh giá:
			\begin{itemize}
				\item Hệ điều hành:
				\item CPU:
				\item RAM:
			\end{itemize}
	\end{itemize}
	Kết quả đánh giá của 4 mô hình:
	\begin{center}
		\begin{tabular}{||c | c | c | c | c||} 
			\hline
			Mô hình & I&II&III&IV\\[0.5ex] 
			\hline\hline
			mAP&0.58045049&0.525435115&0.66937778&0.671899566\\
			\hline
			\makecell{Số lượng ký tự\\ nhận dạng được\footnote{Không xét đến sự đúng sai.}}&1581&1054&1837&1920\\
			\hline
		\end{tabular}
		\captionof{table}{Kết quả mAP của 4 mô hình thử nghiệm.}
	\end{center}
	\begin{center}
		\centering
		\includegraphics[width=0.775\linewidth]{mAP.png}
		\vspace{0.5cm}
		
		\captionof{figure}{Trực quan kết quả mAP cho 4 mô hình thử nghiệm.}
	\end{center}
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\newpage	
	\section{Tổng kết}
	
	\subsection{Kết luận}
	\subsection{Đánh giá ưu, nhược điểm}
	
	\subsubsection{Ưu điểm}
	
	\begin{itemize}
		\item Hệ thống có thể nhận diện được ký tự ở nhiều kích thước khác nhau.
		\item Nhận diện được nhiều biểu thức mà nếu chỉ dùng kỹ thuật phân vùng thì khó có thể làm được (ví dụ như biểu thức có ký tự dính nhau).
		\item Số lượng ký tự nhận diện được khá đa dạng.
	\end{itemize}
	
	\subsubsection{Nhược điểm}
	
	\begin{itemize}
		\item Khi có nhiều ký tự trong ảnh với mật độ lớn thì hệ thống nhận diện gặp nhiều khó khăn.
		\item Tốc độ xử lý một ảnh còn chậm.
		\item Hậu xử lý vẫn còn chưa thật sự hiệu quả.
		\item Các ký tự hoàn toàn trùng lên nhau dễ bị bỏ sót (dấu căn).
	\end{itemize}
	\subsection{Hướng phát triển trong tương lai}
	
	Hệ thống còn nhiều điểm có thể cải thiện thêm, trong đó có hai vấn đề nổi bật là mở rộng tập dữ liệu về cả số lượng ảnh và số lượng nhãn và thêm công đoạn tiền xử lý.
	
	\subsubsection{Mở rộng tập dữ liệu}
	
	\subsubsection{Công đoạn tiền xử lý}
	
	Như nhóm đã đề cập ở phần trước, mô hình IV hoạt động chưa tốt với những ký tự quá lớn, nắm được điều này, nhóm đã thử thu nhỏ ảnh và tiến hành chèn thêm (padding) vào ảnh đã thu nhỏ đó để vẫn được ảnh có kích thước $500 \times 500$ 
	
	\begin{center}
		\centering
		\includegraphics[width=0.775\linewidth]{ensmall.png}
		\vspace{0.5cm}
		
		\captionof{figure}{Ví dụ thu nhỏ ảnh.}
	\end{center}
	
	Sau khi thí nghiệm với một số ảnh, nhóm đã nhận thấy kết quả nhận được là khá tốt.
	
	\begin{center}
		\centering
		\includegraphics[width=0.875\linewidth]{compare_future.png}
		\vspace{0.5cm}
		
		\captionof{figure}{Kết quả thu được sau khi thu nhỏ nội dung ảnh.}
	\end{center}
	
	Vì vậy, nhóm tin rằng có thể thêm vào hệ thống một bộ phận tiền xử lý có nhiệm vụ tự động thu nhỏ nội dung ảnh nếu cần và nếu phù hợp
	
	\subsubsection{Các hướng phát triển khác}
	
	Ngoài ra, hệ thống vẫn còn nhiều điểm có thể cải thiện thêm, trong tương lai, có thể:
	\begin{itemize}
		\item Thêm phần hậu xử lý ở các giai đoạn nhận diện ký tự và sinh cây Lexed - BST.
		\item Cải thiện khả năng nhận diện các ký tự có tỉ lệ diện mạo đặc biệt.
		\item Đưa biểu thức đã nhận dạng được vào ứng dụng (Như có thể vẽ đồ thị, giải phương trình).
	\end{itemize}
	
	
	
	\newpage
	\bibliographystyle{ieeetr}
	\bibliography{ref}
\end{document}






